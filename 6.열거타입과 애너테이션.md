# 열거타입과 애너테이션
자바에서는 특수 목적의 참조타입인 열거 타입과 애너테이션이 있다.

## 1. int 상수 대신 열거 타입을 사용하라
열거타입은 일정 개수의 상수 값을 정의한 다음 그외의 값은 허용하지 않는 타입이다.

    //정수 열거 패턴
    public staic final int APPLE_FUJI = 0;
    public staic final int APPLE_PIPPIN = 1;
    public staic final int APPLE_GRANNY_SMITH = 2;

    public staic final int ORANGE_FUJI = 0;
    public staic final int ORANGE_PIPPIN = 1;
    public staic final int ORANGE_GRANNY_SMITH = 2;

정수 열거 패턴 기법에는 단점이 많다. 타입 안전을 보장할 방법이 없고, 열거 패턴을 위한 별도 이름공간을 지원하지도 않는다. 또한 평범한 상수를 나열한 것 뿐이라 컴파일시 클라이언트 파일에 그대로 새겨진다. 

이러한 열거 패턴의 단점을 보완하고 여러 장점을 가지고 있는 대안이 '열거 타입'이다.

    //열거타입
    public eum Apple { FUJI, PIPPIN, GRANNY_SMITH}
    public eum Orange { NAVEL, TEMPLE, BLOOD}

열거타입 자체는 클래스이며, 상수 하나당 자신의 인스턴스를 하나씩 만들어 public static final 필드로 공개한다. 또 생성자를 제공하지 않으므로 사실상 final이다.

열거타입은 컴파일타임 타입 안전성을 제공하고, 각자의 이름공간이 있어서 이름이 같은 상수도 공존할 수 있다. 또한 새로운 상수를 추가하거나 순서를 바꿔도 다시 컴파일하지 않아도 된다. 그리고 열거타입의 toString 메서드는 출력하기에 적합한 문자열을 내어준다.

    public enum Planet {
        MERCURY(3.302E+23, 2.439e6),
        VENUS (4.869e+24, 6.052e6),
        .....
        .....

        private final double surfaceGravity;

        //생성자
        Planet(double mass, double radius){
            this.mass = mass;
            this.radius = radius;
            surfaceGravity = G * mass / (radius * radius);
        }
    }

    public class WeightTable {
        public static void main(String[] args){
            double earthWeight = Double.parseDouble(args[0]);
            double mass = earthWeight / Planet.EARTH.surfaceGravity();
            for(Planet p : Planet.values())
                System.out.printlf("%s에서의 무게는 %f이다. %n", p, p.surfaceWeight(mass));
        }
    }

열거타입은 정의된 상수들의 값을 배열에 담아 반환하는 정적 메서드인 values를 제공한다. 값은 선언된 순서로 저장된다.

열거타입을 선언한 클래스 혹은 그 패키지에서만 유용한 기능은 private나 package-private 메서드로 구현한다. 또 널리 쓰이는 열거 타입은 톱레벨 클래스로 만들고 특정 톱레벨 클래스에서만 쓰인다면 해등 클래스의 멤버 클래스로 만든다.

열거 타입은 상수별로 다르게 동작하는 코드를 구현하는 수단을 제공한다. 열거 타입에 apply라는 추상 메서드를 선언하고, 각 상수별 클래스 몸체를 자신에 맞게 재정의 하는 방법이다. 이를 '상수별 메서드 구현'이라고 한다.

    //상수별 메서드 구현을 활용한 열거 타입
        public enum Operation {
            PLUS {public double apply(double x, double y) {return x+y;}},
            MINUS {public double apply(double x, double y) {return x-y;}},
            TIMES {public double apply(double x, double y) {return x*y;}},
            DIVIDE {public double apply(double x, double y) {return x/y;}};

            public abstract double apply(double x, double y);
        }

        //상수별 클래스 몸체와 데이터를 사용한 열거타입
        public enum Operation {
            PLUS("+") {
                public double apply(double x, double y) {return x+y}
            },
            MINUS("-") {
                public double apply(double x, double y) {return x-y}
            },
            TIMES("*") {
                public double apply(double x, double y) {return x*y}
            },
            DIVIDE("/") {
                public double apply(double x, double y) {return x/y}
            };

            private final String symbol;

            Opration(String symbol) {this.symbol = symbol;}

            @Ovrride public String toString() {return symbol;}
            public abstract double apply(double x, double y);
        }

또한 열거타입에는 상수 이름을 입력받아 그 이름에 해당하는 상수를 반환해주는 valueOf(String) 메서드가 자동 생성된다.

상수별 메서드 구현에는 열거 타입 상수끼리 코드를 공유하기 어렵다는 단점이 있다.

**열거타입은 필요한 원소를 컴파일타임에 다 알 수 있는 상수 집합이라면 항상 열거 타입을 사용하자.