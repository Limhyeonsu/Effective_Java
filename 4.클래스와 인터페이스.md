# 4. 클래스와 인터페이스
## 1. 클래스와 멤버의 접근 권한을 최소화하라
잘 설계된 컴포넌트는 클래스 내부 데이터와 내부 구현 정보를 외부 컴포넌트로부터 얼마나 잘 숨겼느냐로 구분 한다. 모든 내부 구현을 완벽히 숨겨 구현과 API를 깔끔히 분리하는 정보은닉, 캡슐화가 소프트웨어 설계의 근간이 되는 원리다.

[정보 은닉의 장점]
1) 시스템 개발 속도를 높인다.(여러 컴포넌트를 병렬로 개발 가능)
2) 시스템 관리 비용을 낮춘다.
3) 성능 최적화에 도움을 준다.
4) 소프트웨어 재사용성을 높인다.
5) 시스템 전체가 아직 완성되지 않은 상태에서도 개별 컴포넌트의 동작을 검증할 수 있어 큰 시스템을 제작하는 난이도를 낮춰준다.

정보은닉의 핵심은 접근 제한자를 제대로 활용하는 것이다. 모든 클래스와 멤버의 접근성을 가능한한 좁혀야 한다. (항상 가장 낮은 접근 수준을 부여) 패키지 외부에서 사용할 이유가 없다면 package-private으로 선언하자.

접근제한자)
* private : 멤버를 선언한 톱레벨 클래스에서만 접근 가능
* package-private : 멤버가 소속된 패키지 안의 모든 클래스에서 접근할 수 있다.
* protected : package-private의 접근 범위를 포함하여 이 멤버를 선언한 클래스의 하위 클래스에서도 접근할 수 있다.
* public : 모든 곳에서 접근할 수 있다.

public 클래스에서 protected 멤버는 공개 API이므로 영원히 지원되야 하기 때문에 protected 멤버의 수는 적을수록 좋다. 또 public 클래스의 인스턴스 필드는 되도록 public이 아니어야 한다. 단, 상수라면 public static final 필드로 공개해도 좋다. 이런 필드는 반드시 기본 타입 값이나 불편 객체를 참조해야한다. 가변 객체를 참조한다면 final이 아닌 필드에 적용되는 모든 불이익이 그대로 적용된다.

**길이가 0이 아닌 배열은 모두 변경 가능하므로 public static final 배열 필드를 두거나 이 필드를 반환하는 접근자 메서드를 제공해서는 안된다.

    //보안의 허점이 존재
    public static final Thing[] VALUES = {...};

    //해결책 1)
    private static final Thing[] PRIVATE_VALUES = {...};
    public static final List<Thing> VALUES = Collections.unmodifiableList(Arrays.asList(PRIVATE_VALUES));

    //해결책 2)
    private static final Thing[] PRIVATE_VALUES = {...};
    public static final Thing[] values() {
        return PRIVATE_VALUES.clone();
    }

자바 9에서는 모듈 시스템 개념이 도입되었다. 모듈은 패키지들의 묶음으로 모듈에 속하는 패키지중 공개할 것들을 선언할 수 있어 protected, public 멤버라도 해당 패키지를 공개하지 않았다면 모듈 외부에서 접근할 수 없다. 

## 2. public 클래스에서는 public 필드가 아닌 접근자 메서드를 사용하라
    class Point {
        public double x;
        public double y;
    }

    class Point {
        //1. 멤버들을 public이 아닌 private로 선언한다.
        private double x;
        private double y;

        public Point(double x, double y) {
            this.x = x;
            this.y = y;
        }
        //2. 멤버들에 접근할 수 있는 접근자 메서드를 제공하여 간접적으로 접근하게 한다.
        public double getX() { return x; }
        public double getY() { return y; }

        public void setX(double x) { this.x = x;}
        public void setY(double y) { this.y = y;}
    }

**public 클래스는 절대 가변 필드를 직접 노출해서는 안된다. 

## 3. 변경 가능성을 최소화 하라
불변 클래스란 인스턴스의 내부 값을 수정할 수 없는 클래스다. 불변 클래스는 가변 클래스보다 설계, 구현, 사용하기가 쉽고 오류가 생길 여지가 적어 훨씬 안전하다.

[클래스를 불변으로 만들기 위한 다섯가지 규칙]
1) 객체의 상태를 변경하는 메서드를 제공하지 않는다.
2) 클래스를 확장할 수 없도록 한다.
3) 모든 필드를 final로 선언한다
4) 모든 필드를 private로 선언한다.
5) 자신 외에는 내부의 가변 컴포넌트에 접근할 수 없도록 한다.
___

    public final class Complex {
        private final double re;
        private final double im;

        public Complex(double re, double im) {
            this.re = re;
            this.im = im;
        }

        public double realPart() {return re;}
        public double imaginaryPart() {return im;}

        public Complex plus(Complex c) {
            return new Complex(re + c.re, im + c.im); //새로운 인스턴스를 반환함
        }

        public Complex minus(Complex c) {
            return new Complex(re - c.re, im - c.im);
        }

        public Complex times(Complex c) {
            return new Complex(re * c.re - im * c.im, re * c.im + im * c.re);
        }

        public Complex dividedBy(Complex c) {
            double tmp = c.re * c.re + c.im * c.im;
            return new Complex((re * c.re + im * c.im) / tmp, (im * c.re - re * c.im) / tmp);
        }
        ...
    }

불변객체는 안심하고 공유할 수 있다. 이 점은 방어적 복사도 필요 없다는 결론으로 이어진다. 아무리 복사해봐야 원본과 똑같으니 복사의 의미가 없다. 따라서 불변클래스는 clone 메서드나 복사 생성자를 제공하지 않는게 좋다. 또한 불변객체끼리는 내부 데이터를 공유할 수 있다.

불변클래스의 단점으로는 값이 다르다면 반드시 독립된 객체로 만들어야 한다는 것이다. 값의 가짓수가 많은 경우에 한 요소의 값만 바뀐다고 하더라도 새로 생성해야하므로 비용이 많이 발생하게 된다.

또 불변을 위해 getter가 있다고 무조건 setter를 만들지는 말자, 만약 불변으로 만들 수 없는 클래스라면 변경할 수 있는 부분을 최소한으로 줄이자 그러면 객체를 예측하기 쉬워지고 오류가 생길 가능성이 줄어든다.
