# 람다와 스트림
## 1. 익명 클래스보다는 람다를 사용하라
    //익명클래스
    Collections.sort(words, new Comparator<String>() {
        public int compare(String s1, String s2) {
            return Integer.compare(s1.length(), s2.length());
        }
    });

    //람다식1
    Collections.sort(words, (s1, s2) -> Integer.compare(s1.length(), s2.length()));

    //람다식2
    public enum Operation {
        PLUS   ("+", (x, y) -> x + y),
        MINUS  ("-", (x, y) -> x - y),
        TIMES  ("*", (x, y) -> x * y),
        DIVIDE ("/", (x, y) -> x / y);
    }

타입을 명시해야 코드가 더 명확할 때만 제외하고는 람다의 모든 매개변수 타입은 생략하자, 람다식은 이름이 없고, 문서화도할 수 없어 코드 자체로는 동작이 명확히 설명되지 않거나 코드 줄 수가 많아지면 사용하지 말아야한다.

인스턴스는 런타임에 생성되기 때문에 열거타입 생성자 안의 람다는 인스턴스 멤버에 접근할 수 없다. 따라서 인스턴스 필드나 메서드를 사용해야하는 경우에는 상수별 클래스 몸체를 사용해야한다.

람다는 함수형 인터페이스에서만 쓰이고, 자기 자신을 참조할 수 없다. 람다에서의 this는 바깥 인스턴시를 가리킨다. 따라서 추상클래스의 인스턴스를 만들때나 함수 객체가 자신을 참조해야한다면 반드시 익명클래스를 사용해야한다.

## 2. 람다보다는 메서드 참조를 사용하라
람다가 익명클래스보다 나은점은 간결함이다. 이런 람다보다 더 간결하게 만들 수 있는 방법이 '메서드 참조'이다. 

    map.merge(key, 1, (count, incr) -> count + incr);

    //메서드 참조
    map.merge(key, 1, Integer::sum);

[메서드 참조의 유형]
1) 정적 : Integer::parseInt / str -> Integer.parseInt(str)
2) 한정적(인스턴스) : Instance.now()::isAfter  / Instant then = Instant.now()
3) 비한정적(인스턴스) : String::toLowerCase / str -> str.toLowerCase()
4) 클래스 생성자 : TreeMap< K, V >::new / () -> new TreeMap< K, V >()
5) 배열 생성자 : int[]::new / len -> new int[len]

## 3. 표준 함수형 인터페이스를 사용하라
    //함수형 인터페이스 선언
    @FunctionalInterface interface EldestEntryRemovalFunction<K, V> {
        boolean remove(Map<K,V> map, Map.Entry<K,V> eldest);
    }

위 예제에서 사용한 @FunctionalInterface은 람다용으로 설계된 것임을 알려주고, 해당 인터페이스가 오직 추상 메서드 하나만을 가지고 있어야 컴파일되게 해준다. 따라서 유지보수 과정에서 누군가 실수로 메서드를 추가하지 못하게 막아준다. 그러니 직접 만든 함수형 인터페이스에는 항상 @FunctionalInterface 애너테이션을 사용하자

자바표준라이브러리에 다양한 용도의 표준 함수형 인터페이스가 담겨있다. 필요한 용도에 맞는게 있다면, 직접 구현하지 말고 표준 함수형 인터페이스를 활용하자 또한 표준 함수형 인터페이스에는 유용한 디폴트 메서드를 많이 제공하므로 다른 코드와의 상호 운용성도 크게 좋아질 것이다.

[기본 함수형 인터페이스]
    
    * UnaryOperation<T>  / T apply(T t)         / String::toLowerCase
    * BinaryOperation<T> / T applay(T t1, T t2) / BigInteger::add
    * Predicate<T>       / boolean test(T t)    / Collection::isEmpty
    * Function<T, R>     / R apply(T t)         / Arrays::asList
    * Supplier<T>        / T get()              / Instant::now
    * Consumer<T>        / void accept(T t)     / System.out::println

기본 인터페이스는 기본 타입인 int, long, double용으로 변형이 생겨난다. 인터페이스의 이름 앞에 기본 타입 이름을 붙여 int -> IntPredicate, long -> LongBinaryOperation 식으로 사용한다.

*인수와 같은 타입을 반환하는 함수는 UnaryOperation이므로, Function 인터페이스의 변형은 입력과 결과의 타입이 항상 다르다.

또 기본 함수형 인터페이스 중 BiPredicate< T, U >, BiFunction< T, U, R >, BiConsumer< T, U >는 인수를 2개씩 받는 변형이 있다.

BooleanSupplier 인터페이스는 boolean을 반환하도록 한 Supplier의 변형이다.

이렇게 표준 함수형 인터페이스는 총 43개로 되어 있다.

자주 본 Comparator< T > 인터페이스의 경우 구조적으론 ToIntBiFunction< T, U >와 동일하다. 하지만 독자적으로 사용하는 이유는
1) 자주 사용되며, 이름 자체가 용도를 명확히 설명해준다.
2) 반드시 지켜야할 규약을 담고 있다.
3) 유용한 디폴트 메서드를 제공한다.

위 3가지중 하나 이상을 만족한다면 전용 함수형 인터페이스를 구현해야하는 것은 아닌지 진중히 고민해야한다.
또한 주의할 점으로 서로 다른 함수형 인터페이스를 같은 위치의 인수로 받는 메서드들을 다중 정의하지 말아야한다. 클라이언트에게 모호함을 안겨주어 문제가 일어나기도 하기 때문이다.

## 4. 스트림은 주의해서 사용하라
스트림 API는 다량의 데이터 처리 작업을 돕고자 자바8에서 추가되었다. 스트림 안의 데이터 원소들은 객체 참조나 기본 타입 값이고, int, long, double 세가지를 지원한다.

스트림 파이프라인은 소스 스트림에서 시작해 종단 연산으로 끝나며, 그 사이에 하나 이상의 중간 연산이 있을 수 있다. 중간 연산은 모두 한 스트림을 다른 스트림으로 변환하고, 종단 연산은 마지막 중간 연산이 내놓은 스트림에 최후의 연산을 가한다.

스트림 파이프라인은 지연 평가된다. 평가는 종단 연산이 호출될 때 이뤄지기 때문에 종단 연산이 없는 스트림 파이프라인은 아무 일도 하지 않는 명령어인 no-op와 같으므로 종단 연산을 빼먹는 일지 절대 없도록 하자.

또한 스트림 API는 메서드 연쇄를 지원하는 플루언트 API다. 즉 모든 호출을 연결하여 단 하나의 표현식으로 완성할 수 있다. 기본적으로 순차적으로 수행되며 병렬로 실행하려면 스트림중 하나에서 parallel 메서드를 호출해주기만 하면 된다.

    public class Anagrams {
        public static void main(String[] args) throw IOException {
            File dictionary = new File(args[0]);
            int minGroupSize = Integer.parseInt(args[1]);

            Map<String, Set<String>> groups = new HashMap<>();
            try(Scanner s = new Scanner(dictionary)) {
                while (s.hasNext()) {
                    String word = s.next();
                    groups.computeIfAbsent(alphabetize(word)), (unused) -> new TreeSet<>()).add(word);
                }
            }
    // computeIfAbsent메서드 : 맵안에 키가 있는지 찾는 다음 있으면 키에 매핑된 값 반환,
    // 없으면 건네진 함수 객체를 키에 적용하여 값을 계산해낸 다음 그 키와 값을 매핑하고, 계산된 값 반환

            for(Set<String> group : groups.values())
                if(group.size() >= minGroupSize)
                    System.out.println(group.size() + " : " + group);
        }

        private static String alphabetize(String s) {
            char[] a = s.toCharArray();
            Arrays.sort(a);
            return new String(a);
        }
    }

    //스트림을 과하게 사용한 버전
    public class Anagrams {
        public static void main(String[] args) throw IOException {
            Path dictionary = Paths.get(args[0]);
            int minGroupSize = Integer.parseInt(args[1]);

            try (Stream<String> words = Files.lines(dictionary)) {
                words.collect(groupingBy(word -> word.chars().sorted().collect(StringBuilder::new,(sb, c) -> sb.append((char) c), StringBuilder::append).toString())).values().stream().filter(group -> group.size() >= minGroupSize).map(group -> group.size() + " : " +group).forEach(System.out::println);
            }
        }
    }

    //스트림을 적절히 사용한 버전
    public class Anagrams {
        public static void main(String[] args) throw IOException {
            Path dictionary = Paths.get(args[0]);
            int minGroupSize = Integer.parseInt(args[1]);

            try (Stream<String> words = Files.lines(dictionary)) {
                word.collect(groupingBy(word -> alphabetize(word))).values().stream().filter(group -> group.size() >= minGroupSize).forEach(g -> System.out.println(g.size() + " : " + g));
            }
        }
    }

**람다의 매개변수 이름은 주의해서 정해야한다. 람다에서는 타입 이름을 자주 생략하므로 매개 변수 이름을 잘 지어야 스트림 파이프라인의 가독성이 유지된다.

스트림 파이프라인은 되풀이 되는 계산을 함수객체로 표현하고 반복 코드에서는 코드 블록을 사용해 표현한다. 함수 객체로는 할 수 없지만 코드 블록으로는 할 수 있는 일들로 다음과 같은 예가 있다.
* 코드 블록에서는 범위 안의 지역변수를 읽고 수정할 수 있다. 반면 람다에서는 final인 변수만 읽을 수 있고, 지역 변수를 수정하는 것은 불가능하다.
* 코드 블록에서는 return 문을 사용해 메서드에서 빠져나가거나, break나 continue문으로 블록 바깥의 반복문을 종료하거나 반복을 한 번 건너뛸 수 있다.

한편 스트림으로 처리할 수 없는 일도 있는데 데이터가 파이프라인의 여러 단계를 통과할 때 각 단계에서의 값들에 동시에 접근하기 어려운 경우다. 스트림 파이프라인은 일단 한 값을 다른 값에 매핑하고 나면 원래의 값을 잃는 구조이기 때문이다.

또 스트림과 반복문 중 어느 쪽을 사용해야 할지 알기 어려운 작업도 많다.

    private static List<Card> newDeck() {
        List<Card> result = new ArrayList<>();
        //중첩 for-each 문 사용
        for(Suit suit : Suit.values())
            for(Rank rank : Rank.values())
                result.add(new Card(suit, rank));
        return result;
    }

    private static List<Card> newDeck() {
        //중첩 람다 사용
        return Stream.of(Suit.values()).flatMap(suit -> Stream.of(Rank.values()).map(rank -> new Card(suit, rank))).collect(toList());
    }