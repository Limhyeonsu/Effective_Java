# 메서드
## 1. 매개변수가 유효한지 검사하라
매개변수의 값에 대한 검사는 메서드 몸체가 시작되기 전에 검사해야한다. (오류는 가능한 한 빨리 잡아야한다.) 매개변수 검사에 실패하면 실패 원자성을 어기는 결과를 낳을 수 있다.

    /**
    * 현재값 mod m 값을 반환한다. 이 메서드는 항상 음이 아닌 BigInteger를 반환한다는 점에서 remainder 메서드와 다르다
    *@param m 계수(양수여야한다)
    *@return 현재값 mod m
    *@throw ArithmeticException m이 0보다 작거나 같으면 발생
    */
    public BigInteger mod(BigInteger m) {
        if (m.signum() <= 0)
            throw new ArithmeticException("계수(m)은 양수여야 합니다. " + m);
        ....
    }

    //자바의 null검사 기능 사용
    this.strategy = Object.requireNonNull(strategy, "전략");

위 예제에서 requireNonNull은 예외 메세지도 지정할 수 있다. 또한 입력값을 그대로 반환하므로 값을 사용하는 동시에 null검사도 가능하다.

public이 아닌 메서드라면 단언문(assert)을 사용해 매개변수 유효성을 검증할 수 있다.

    private static void sort(long a[], int offset, int length) {
        assert a != null;
        assert offset >= 0 && offset <= a.length;
        assert length >= 0 && a.length - offset;
    }

이 단언문들은 자신이 단언한 조건이 무조건 참이라고 선언한다.

**메서드는 최대한 범용적으로 설계해야한다. 메서드가 건네받은 값으로 무언가 제대로 된 일을 할 수 있다면 매개변수 제약은 적을수록 좋다.

## 2. 적시에 방어적 복사본을 만들라
자바는 안전한 언어이고, 자바로 작성한 클래스는 불변식이 지켜진다. 

    //불변식을 지키지 못한 클래스
    public final class Period {
        private final Date start;
        private final Date end;

        public Period(Date start, Date end) {
            if (start.compareTo(end) > 0)
                throw new IllegalArgumentException(start + "가" + end + "보다 늦다.");
            this.start = start;
            this.end = end;
        }

        public Date start() {
            return start;
        }

        public Date end() {
            return end();
        }

        ....
    }

    Date start = new Date();
    Date end = new Date();
    Period p = new Period(start, end);
    end.setYear(78);

Date는 가변이라 이를 이용하면 불변식을 깨뜨릴 수 있다. 자바8 이후로는 Date 대신 Instant를 사용하면 된다. 외부 공격으로부터 Period 인스턴스의 내부를 보호하려면 생성자에서 받은 가변 매개변수 각각을 방어적으로 복사해야한다. 그리고 Period 인스턴스 안에서는 원본이 아닌 복사본을 사용한다.

    //방어적 복사를 사용한 버전
    public Period(Date start, Date end) {
        this.start = new Date(start.getTime());
        this.end = new Date(end.getTime());

        if(this.start.compareTo(this.end) > 0)
            throw new IllegalArgumentException(start + "가" + end + "보다 늦다.");
    }

위 예제에서 매개변수의 유효성을 검사하기 전에 방어적 복사본을 만들고, 복사본으로 유효성 검사를 한 점에 주목하자.

또한 매개변수가 제 3자에 의해 확장될 수 있는 타입이라면 방어적 복사본을 만들 때 clone을 사용해서는 안된다.(clone이 악의를 가진 하위 클래스의 인스턴스를 반환할 수도 있기 때문에)

    //수정한 접근자
    public Date start() {
        return new Date(start.getTime());
    }
    public Date end() {
        return new Date(end.getTime());
    }

**클래스가 불변이든 가변이든 가변인 내부 객체를 클라이언트에 반환할 때는 반드시 심사숙고 해야한다.