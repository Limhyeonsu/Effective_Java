# 모든 객체의 공통 메서드
Object는 기본적으로 상속해서 사용하도록 설계 되었다. 따라서 Object를 상속하는 클래스, 즉 모든 클래스는 이 메서드들(equals, hashCode, toString, clone, finalize)은 규약에 맞게 재정의 해야한다.

## 1. equals는 일반 규약을 지켜 재정의하라
equals는 다음의 상황에 해당한다면 재정의 하지 않는 것이 최선이다.
1) 각 인스턴스가 본질적으로 고유하다.
2) 인스턴스의 논리적 동치성을 검사할 일이 없다.
3) 상위 클래스에서 재정의한 equals가 하위 클래스에도 딱 들어맞는다.
4) 클래스가 private이거나 package-private이고 equals 메서드를 호출할 일이 없다.

equals를 재정의 해야 할 때는 객체 식별성이 아니라 논리적 동치성을 확인해야하는데 상위 클래스의 equals가 논리적 동치성을 비교하도록 재정의되지 않았을 때다(주로 값 클래스들이 해당한다)

__[Objece 명세 규약]__
equals는 동치관계를 구현하며 다음을 만족한다. (동치관계 : 집합을 서로 같은 원소들로 이뤄진 부분 집합으로 나누는 연산)

1) 반사성 : 객체는 자기 자신과 같아야 한다.
2) 대칭성 : 두 객체는 서로에 대한 동치여부에 똑같이 답해야한다.
3) 추이성 : 첫 번째 객체와 두 번째 객체가 같고, 두 번째 객체와 세 번째 객체가 같다면, 첫 번째 객체와 세 번째 객체도 같아야 한다.
___

    public class Point {
        private final int x;
        private final int y;
        
        public Point(int x, int y){
            this.x = x;
            this.y = y;
        }
        @Override public boolean equals(Object o){
            if(!(o instanceof Point))
                return false;
            Point p = (Point) o;
            return p.x == x && p.y == y;
        }
    }

    public class ColorPoint extends Point{
        private final Color color;
        
        public ColorPoint(int x, int y, Color color){
            super((x, y);
            this.color = color;
        }
    }

    //대칭성 위배
    @Override public boolean equals(Object o){
        if(!(o instanceof ColorPoint))
            return false;
        return super.equals(o) && ((ColorPoint) o).color == color;
    }

    //추이성 위배
    @Override public boolean equals(Object o){
        if(!(o instanceof Point))
            return false;
        if(!(o instanceof ColorPoint))
            return o.equals(this);
        return super.equals(o) && ((ColorPoint) o).color == color;
    }

    //리스코프 치환 위배
    @Override public boolean equals(Object o){
        if(o == null || o.getClass() != getClass())
            return false;
        Point p = (Point) o;
        return p.x == x && p.y == y;
    }

    //규약을 지키면서 값 추가하기
    public class ColorPoint {
        private final Point point;
        private final Color color;
        
        public ColorPoint(int x, int y, Color color){
            point = new Point(x, y);
            this.color = Objects.requireNonNull(color);
        }
        
        public Point asPoint() {
            return point;
        }
        @Override public boolean equals(Object o) {
            if(!(o instanceof ColorPoint))
                return false;
            ColorPoint cp = (ColorPoint) o;
            return cp.point.equals(point) && cp.color.equals(color);
        }
    }

4) 일관성 : 두 객체가 같다면 앞으로도 영원히 같아야 한다. equals의 판단에 신뢰할 수 없는 자원이 끼어들게 해서는 안된다.
5) null-아님 : 모든 객체가 null과 같지 않아야 한다. 그렇다고 명시적으로 null검사를 할 필요는 없고 instanceof 연산자를 통해 입력 매개변수가 올바른 타입인지 확인하면 된다.

**주의사항) equals를 정의할 땐 hashcode도 반드시 재정의 해야한다, Object 외의 타입을 매개변수로 받는 equals를 선언하지 말자.