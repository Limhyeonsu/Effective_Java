# 객체 생성과 파괴
## 1. 생성자 대신 정적 팩터리 메서드를 고려하라
클래스는 클래스의 인스턴스를 반환하는 생성자와 별도로 정적 팩터리 메서드를 제공한다.

    public static Boolean valueOf(boolean b){
        return b ? Boolean.TRUE : Boolean.FALSE;
    }

[정적 팩터리 메서드가 생성자보다 좋은 장점]
1) 이름을 가질 수 있다 : 한 클래스에 시그니처가 같은 생성자가 여러개 필요할 것 같으면 생성자를 정적 팩터리 메서드로 바꾸고 차이를 잘 드러내는 이름을 지어주면 문서를 찾아보지 않고도 의미를 쉽게 알 수 있다.
2) 호출될 때마다 인스턴스를 새로 생성하지 않아도 된다 : 인스턴스를 재활용하는 식으로 불필요한 객체생성을 피할 수 있어 같은 객체가 자주 요청되는 상황에서 성능을 이끌어준다.
3) 반환타입의 하위 타입 객체를 반환할 수 있는 능력이 있다 : 반환할 객체의 클래스를 자유롭게 선택할 수 있게 하는 유연성을 제공함
4) 입력 매개변수에 따라 매번 다른 클래스의 객체를 반환할 수 있다 : 반환 타입의 하위 타입이기만 하면 어떤 클래스의 객체를 반환하든 상관 없다.
5) 정적 팩터리 메서드를 작성하는 시점에는 반환할 객체의 클래스가 존재하지 않아도 된다 : 이런 유연함은 서비스 제공자 프레임워크를 만드는 근간이 된다.(대표적으로  JDBC) 

**서비스 제공자 프레임워크는 3개의 핵심 컴포넌트로 이루어진다. 1)구현체의 동작을 정의하는 서비스 인터페이스, 2)구현체를 등록할 때 사용하는 제공자 등록 API, 3)인스턴스를 얻을 때 사용하는 서비스 접근 API, 이 서비스 접근 API가 서비스 제공자 프에임워크의 근간인 유연한 정적 팩터리의 실체이다.

[단점]
1) 정적 팩터리 메서드만 제공하면 상속을 통한 하위 클래스를 만들 수 없다.
2) 정적 팩터리 메서드는 프로그래머가 찾기 어렵다 : 생성자처럼 API 설명에 명확히 드러나있지 않음

## 2. 생성자에 매개변수가 많다면 빌더를 고려하라
    //점층적 생성자 패턴
    class NutritionFacts{
        private final int servingSize;  //(ml. 1회 제공량)    필수
        private final int servings;     //(회, 총 n회 제공량)  필수
        private final int calories;     //(1회 제공량당)      선택
        private final int fat;          //(g/1회 제공량)      선택
        private final int sodium;       //(mg/1회 제공량)     선택
        private final int carbohydrate; //(g/1회 제공량)      선택

        public NutritionFacts(int servingSize, int servings){
            this(servingSize, servings, 0);
        }

        public NutritionFacts(int servingSize, int servings, int calories){
            this(servingSize, servings, calories, 0);
        }

        public NutritionFacts(int servingSize, int servings, int calories, int fat){
            this(servingSize, servings, calories, fat, 0);
        }

        public NutritionFacts(int servingSize, int servings, int calories, int fat, int sodium){
            this(servingSize, servings, calories, fat, sodium);
        }

        public NutritionFacts(int servingSize, int servings, int calories, int fat, int sodium, int carbohydrate){
            this.servingSize = servingSize;
            this.servings = servings;
            this.calories = calories;
            this.fat = fat;
            this.sodium = sodium;
            this.carbohydrate = carbohydrate;
        }
    }

    점층적 생성자 패턴은 매개변수의 개수가 많아지면 가독성이 떨어지고 사용하지 않을 매개변수에도 값을 지정해주어야하는 번거로움이 있다.

    //지바빈즈 패턴
    public class NutritionFacts {
        private int servingSize = -1;
        private int servings = -1;
        private int calories = 0;
        private int fat = 0;
        private int sodium = 0;
        private int carbohydrate = 0;

        public NutritionFacts() {}

        public void setServingSize(int val){ servingSize = val; }
        public void setServings(int val) { servings = val; }
        public void setCalories(int val) { calories = val; }
        public void setFat(int val) { fat = val; }
        public void setSodium(int val) { sodium = val; }
        public void setCarbohydrate(int val) { carbohydrate = val; }
    }

자바빈즈 패턴에서는 객체 하나를 만들기 위해 메서드를 여러개 호출해야하고 객체가 완전히 생성되기 전까지 일관성이 무너진 상태가 된다.

빌더 패턴은 점층적 생성자 패턴의 안전성과 자바 빈즈 패턴의 가독성을 겸비한 패턴이다.

    //빌더 패턴
    class NutritionFacts {
        private final int servingSize;
        private final int servings;
        private final int calories;
        private final int fat;
        private final int sodium;
        private final int carbohydrate;

        public static class Builder {
            //필수 매개변수
            private final int servingSize;
            private final int servings;

            //선택 매개변수 - 기본값으로 초기화
            private int calories = 0;
            private int fat = 0;
            private int sodium = 0;
            private int carbohydrate = 0;

            public Builder(int servingSize, int servings) {
                this.servingSize = servingSize;
                this.servings = servings;
            }

            public Builder fat(int val) {
                fat = val;
                return this;
            }

            public Builder sodium(int val) {
                sodium = val;
                return this;
            }

            public Builder carbohydrate(int val) {
                carbohydrate = val;
                return this;
            }

            public NutritionFacts build() {
                return new NutritionFacts(this);
            }
        }
        private NutritionFacts(Builder builder) {
            servingSize = builder.servingSize;
            servings = builder.servings;
            calories = builder.calories;
            fat = builder.fat;
            sodium = builder.sodium;
            carbohydrate = builder.carbohydrate;
        }
    }
    NutritionFacts cocaCola = new NutritionFacts.Builder(240, 0)
            .calories(100).sodium(35).carbohydrate(27).build();

빌더패턴의 세터 메서드들은 빌더 자신을 반환하기 때문에 연쇄적으로 호출할 수 있다.