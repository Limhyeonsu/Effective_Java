# 일반적인 프로그래밍 원칙
## 1. 지역변수의 범위를 최소화하라
지역변수의 유효범위를 최소로 줄이면 코드 가독성과 유지보수성이 높아지고 오류 가능성이 낮아진다. 따라서 지역변수는 선언과 동시에 초기화하는 것이 좋다. 초기화에 필요한 정보가 충분하지 않다면 충분해질 때까지 선언을 미뤄야 한다. 

반복문의 경우 반복변수의 범위가 반복문의 몸체, 그리고 for 키워드와 몸체 사이의 괄호 안으로 제한된다.

    //컬렉션이나 배열을 순회하는 경우
    for(Element e : c) {
        ...
    }

    //반복자가 필요할 때의 관용구
    for(Iterator<Element> i = c.iterator(); i.hasNext();){
        Element e = i.next();
    }

for문을 사용하면 반복문이 사용한 원소와 반복자의 유효 범위가 반복문 종료와 함께 끝나기 때문에 오류를 최소화 할 수 있고, 똑같은 이름의 변수를 여러 반복문에서 사용해도 서로 영향을 주지 않는다.

지역변수 범위를 최소화 하는 마지막 방법으로 메서드를 작게 유지하고 한 가지 기능에 집중하는 것이다.

## 2. 전통적인 for문보다는 for-each문을 사용하라
for-each문의 정식이름은 '향상된 for 문'이다. 반복자와 인덱스 변수를 사용하지 않으니 코드가 깔끔해지고 오류가 날 일도 없다. 또한 하나의 관용구로 컬렉션과 배열을 모두 처리할 수 있어서 어떤 컨테이너를 다루는지는 신경 쓰지 않아도 된다.

컬렉션을 중첩해 순회해야 한다면 for-each문의 이점이 더욱 커진다.

    //버그 찾기
    enum Suit {CLUB, DIAMOND, HEART, SPADE}
    enum Rank {ACE, DEUCE, THREE, FOUR, FIVE, SIX, SEVEN, EIGHT, NINE, TEN, JACK, QUEEN, KING}

    static Collection<Suit> suits = Arrays.asList(Suit.values());
    static Collection<Rank> ranks = Arrays.asList(Rank.values());

    List<Card> deck = new ArrayList<>();
    for(Iterator<Suit> i = suits.iterator(); i.hasNext();)
        for(Iterator<Rank> j = ranks.iterator(); j.hasNext();)
            deck.add(new Card(i.next(), j.next()));  //버그 발생
    
위 예제에서 마지막 줄에 i.next()에서 버그가 발생한다. next()는 Suit 하나당 한 번씩만 불려야하는데 안쪽 반복문에서 호출되는 바람에 Rank 하나당 한 번씩 불리고 있다. 그래서 Suit가 바닥나면 반복문에서 예외를 던진다.

    //같은 버그 다른 증상
    enum Face {ONE, TWO, THREE, FOUR, FIVE, SIX}
    ....
    Collection<Face> faces = EnumSet.allOf(Face.class);

    for(Iterator<Face> i = faces.iterator(); i.hasNext();)
        for(Iterator<Face> j = faces.iterator(); j.hasNext();)
            System.out.println(i.nexr() + " " + j.next());

    //문제 해결(좋은 방법 아님)
    for(Iterator<Suit> i = suit.iterator(); i.hasNext();){
        Suit suit = i.next();
        for(Iterator<Rank> j = ranks.iterator(); j.hasNext();)
            deck.add(new Card(suit, j.next()));
    }

    //for-each문 사용
    for(Suit suit : suits)
        for(Rank rank : ranks)
            deck.add(new Card(suit, rank));

for-each문을 사용하면 문제도 해결되고 코드도 간결해진다.

[for-each문을 사용할 수 없는 상황]
1) 파괴적인 필터링 : 컬렉션을 순회하면서 선택된 원소를 제거해야한다면 반복자의 remove 메서드를 호출해야한다.
2) 변형 : 리스트나 배열을 순회하면서 원소의 값 일부, 또는 전체를 교체해아하는 경우 인덱스를 사용해야한다.
3) 병렬 반복 : 여러 컬렉션을 병렬로 순회해야 한다면 각각의 반복자와 인덱스 변수를 사용해 엄격하고 명시적으로 제어해야한다.

**for-each문은 컬렉션과 배열은 물론 Iterator 인터페이스를 구현한 객체라면 무엇이든 순회할 수 있다.

## 3. 라이브러리를 익히고 사용하라
[라이브러리 사용의 이점]
* 표준 라이브러리를 사용하면 그 코드를 작성한 전문가의 지식과 여러분보다 앞서 사용한 다른 프로그래머들의 경험을 활용할 수 있다.
* 핵심적인 일과 크게 관련 없는 문제를 해결하느라 시간을 허비하지 않아도 된다.
* 따로 노력하지 않아도 성능이 지속해서 개선된다.
* 기능이 점점 많아진다
* 내가 작성한 코드가 많은 사람에게 낯익은 코드가 된다.

## 4. 정확한 답이 필요하다면 float와 double은 피하라
float와 double 타입은 과학과 공학 계산용으로 설계되어 넓은 범위의 수를 빠르게 정밀한 근사치로 계산하도록 설계되어있다. 따라서 정확한 결과가 필요한 경우에는 사용하면 안된다. 특히 금융 관련 계산과는 맞지 않다.

    System.out.println(1.03 - 0.42);  //0.6100000000000001
    System.out.println(1.00 - 9 * 0.10);  //0.09999999999999998

    //오류 발생
    public static void main(String[] args) {
        double funds = 1.00;
        int itemsBought = 0;
        for(double price = 0.10; funds >= price; price += 0.10) {
            funds -= price;
            itemsBought++;
        }
        System.out.println(itemsBought + "개 구입");
        System.out.println("잔돈(달러):" + funds);  //사탕 3개구입후 잔돈0.39999999999999999
    }

    //BigDecimal을 사용한 해법 (속도가 느림)
    public static void main(String[] args) {
        final BigDecimal TEN_CENTS = new BigDecimal(".10");

        int itemsBought = 0;
        BigDecimal funds = new BigDecimal("1.00");
        for (BigDecimal price = TEN_CENTS; price = price.add(TEN_CENTS)){
            funds = funds.subtract(price);
            itemsBought++;
        }
        System.out.println(itemsBought + "개 구입");
        System.out.println("잔돈(달러):" + funds);  
    }

    //정수 타입 사용
    public static void main(String[] args) {
        int itemsBought = 0;
        int funds = 100;
        for(int price = 10; funds >= price; price += 10){
            funds -= price;
            itemsBought++;
        }
        System.out.println(itemsBought + "개 구입");
        System.out.println("잔돈(달러):" + funds);  
    }

BigDecimal은 기본타입보다 쓰기가 불편하고 느리다. 따라서 성능이 중요하고 소수점을 직접 추적할 수 있고, 숫자가 너무 크지 않다면 int나 long을 사용하자

## 5. 박싱된 기본 타입보다는 기본 타입을 사용하라
박싱된 기본타입과 기본타입의 차이점
1) 기본 타입은 값만 가지고 있고, 박싱된 기본타입은 값 + 식별성의 속성을 갖는다.
2) 기본 타입의 값은 언제나 유효하나 박싱된 기본 타입은 유효하지 않은 값(null)을 가질 수 있다.
3) 기본 타입이 박싱된 기본 타입보다 시간과 메모리 사용면에서 더 효율적이다.

박싱된 기본타입의 두 인스턴스의 값이 같더라도 == 연산자를 사용하면 false가 반환된다. 따라서 박싱된 기본타입의 인스턴스 값을 비교하는 경우에는 기본타입으로 저장한 다음 비교를 수행해야 식별성 검사가 이루어지지 않는다.

    public class Unbelievable {
        static Integer i;

        public static void main(String[] args) {
            if (i == 42)   //null exception 발생
                System.out.println("***");
    }

기본 타입과 박싱된 기본 타입을 혼용한 연산에서는 박싱된 기본 타입의 박싱이 자동으로 풀린다. 따라서 null를 언박싱 하면 exception이 발생하게 된다.

박싱된 기본 타입을 사용하는 경우
* 컬렉션의 원소, 키, 값으로 사용
* 매개변수화 타입, 매개변수화 메서드의 타입 매개변수의 사용
* 리플렉션을 통해 메서드를 호출할 때 사용