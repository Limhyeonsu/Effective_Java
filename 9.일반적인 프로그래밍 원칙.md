# 일반적인 프로그래밍 원칙
## 1. 지역변수의 범위를 최소화하라
지역변수의 유효범위를 최소로 줄이면 코드 가독성과 유지보수성이 높아지고 오류 가능성이 낮아진다. 따라서 지역변수는 선언과 동시에 초기화하는 것이 좋다. 초기화에 필요한 정보가 충분하지 않다면 충분해질 때까지 선언을 미뤄야 한다. 

반복문의 경우 반복변수의 범위가 반복문의 몸체, 그리고 for 키워드와 몸체 사이의 괄호 안으로 제한된다.

    //컬렉션이나 배열을 순회하는 경우
    for(Element e : c) {
        ...
    }

    //반복자가 필요할 때의 관용구
    for(Iterator<Element> i = c.iterator(); i.hasNext();){
        Element e = i.next();
    }

for문을 사용하면 반복문이 사용한 원소와 반복자의 유효 범위가 반복문 종료와 함께 끝나기 때문에 오류를 최소화 할 수 있고, 똑같은 이름의 변수를 여러 반복문에서 사용해도 서로 영향을 주지 않는다.

지역변수 범위를 최소화 하는 마지막 방법으로 메서드를 작게 유지하고 한 가지 기능에 집중하는 것이다.

## 2. 전통적인 for문보다는 for-each문을 사용하라
for-each문의 정식이름은 '향상된 for 문'이다. 반복자와 인덱스 변수를 사용하지 않으니 코드가 깔끔해지고 오류가 날 일도 없다. 또한 하나의 관용구로 컬렉션과 배열을 모두 처리할 수 있어서 어떤 컨테이너를 다루는지는 신경 쓰지 않아도 된다.

컬렉션을 중첩해 순회해야 한다면 for-each문의 이점이 더욱 커진다.

    //버그 찾기
    enum Suit {CLUB, DIAMOND, HEART, SPADE}
    enum Rank {ACE, DEUCE, THREE, FOUR, FIVE, SIX, SEVEN, EIGHT, NINE, TEN, JACK, QUEEN, KING}

    static Collection<Suit> suits = Arrays.asList(Suit.values());
    static Collection<Rank> ranks = Arrays.asList(Rank.values());

    List<Card> deck = new ArrayList<>();
    for(Iterator<Suit> i = suits.iterator(); i.hasNext();)
        for(Iterator<Rank> j = ranks.iterator(); j.hasNext();)
            deck.add(new Card(i.next(), j.next()));  //버그 발생
    
위 예제에서 마지막 줄에 i.next()에서 버그가 발생한다. next()는 Suit 하나당 한 번씩만 불려야하는데 안쪽 반복문에서 호출되는 바람에 Rank 하나당 한 번씩 불리고 있다. 그래서 Suit가 바닥나면 반복문에서 예외를 던진다.

    //같은 버그 다른 증상
    enum Face {ONE, TWO, THREE, FOUR, FIVE, SIX}
    ....
    Collection<Face> faces = EnumSet.allOf(Face.class);

    for(Iterator<Face> i = faces.iterator(); i.hasNext();)
        for(Iterator<Face> j = faces.iterator(); j.hasNext();)
            System.out.println(i.nexr() + " " + j.next());

    //문제 해결(좋은 방법 아님)
    for(Iterator<Suit> i = suit.iterator(); i.hasNext();){
        Suit suit = i.next();
        for(Iterator<Rank> j = ranks.iterator(); j.hasNext();)
            deck.add(new Card(suit, j.next()));
    }

    //for-each문 사용
    for(Suit suit : suits)
        for(Rank rank : ranks)
            deck.add(new Card(suit, rank));

for-each문을 사용하면 문제도 해결되고 코드도 간결해진다.

[for-each문을 사용할 수 없는 상황]
1) 파괴적인 필터링 : 컬렉션을 순회하면서 선택된 원소를 제거해야한다면 반복자의 remove 메서드를 호출해야한다.
2) 변형 : 리스트나 배열을 순회하면서 원소의 값 일부, 또는 전체를 교체해아하는 경우 인덱스를 사용해야한다.
3) 병렬 반복 : 여러 컬렉션을 병렬로 순회해야 한다면 각각의 반복자와 인덱스 변수를 사용해 엄격하고 명시적으로 제어해야한다.

**for-each문은 컬렉션과 배열은 물론 Iterator 인터페이스를 구현한 객체라면 무엇이든 순회할 수 있다.

## 3. 라이브러리를 익히고 사용하라
[라이브러리 사용의 이점]
* 표준 라이브러리를 사용하면 그 코드를 작성한 전문가의 지식과 여러분보다 앞서 사용한 다른 프로그래머들의 경험을 활용할 수 있다.
* 핵심적인 일과 크게 관련 없는 문제를 해결하느라 시간을 허비하지 않아도 된다.
* 따로 노력하지 않아도 성능이 지속해서 개선된다.
* 기능이 점점 많아진다
* 내가 작성한 코드가 많은 사람에게 낯익은 코드가 된다.