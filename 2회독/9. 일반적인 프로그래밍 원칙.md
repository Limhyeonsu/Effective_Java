# 9. 일반적인 프로그래밍 원칙

## 아이템 57. 지역변수의 범위를 최소화하라
지역변수의 유효 범위를 최소로 줄이면 코드 가독성과 유지보수성이 높아지고 오류 가능성은 낮아진다. `지역변수의 범위를 줄이는 가장 강력한 기법은 가장 처음 쓰일 때 선언하기 다.` 지역변수를 생각 없이 선언하다 보면 변수가 쓰이는 범위보다 너무 앞서 선언하거나, 다 쓴 뒤에도 여전히 살아 있게 되기 쉽다. 또 `거의 모든 지역변수는 선언과 동시에 초기화해야 한다.` 초기화에 필요한 정보가 충분하지 않다면 충분해질 때까지 선언을 미뤄야 한다.

반복문에서는 반복 변수의 범위가 반복문의 몸체, 그리고 for 키워드와 몸체 사이의 괄호 안으로 제한된다. 따라서 반복 변수의 값을 반복문이 종료된 뒤에도 써야하는 상황이 아니라면 while 문보다는 for문을 사용하는 것이 좋다.

지역변수 범위를 최소화하는 마지막 방법은 `메서드를 작게 유지하고 한 가지 기능에 집중하는 것이다.`

### 아이템 58. 전통적인 for문 보다는 for-each문을 사용하라
```java
//컬렉션 순회
for(Iterator<Element> i = c.iterator(); i.hasNext();) {
    Element e = i.next();
    ....
}

//배열 순회
for(int i = 0; i < a.length; i++) {
    ....
}
```
for-each문(향상된 for문)을 사용하게 되면 반복자와 인덱스 변수를 사용하지 않아 코드가 깔끔해지고 오류가 날 일도 없다.
```java
for(Element e : elements) {
    ...
}
```
[for-each문을 사용할 수 없는 상황]
* 파괴적인 필터링 - 컬렉션을 순회하면서 선택된 원소를 제거해야 한다면 반복자의 remove 메서드를 호출해야 한다.
* 변형 - 리스트, 배열을 순회하면서 그 원소의 값의 일부 혹은 전체를 교체해야 한다면 인덱스를 사용해야 한다.
* 병렬 반복 - 여러 컬렉션을 병렬로 순회해야 한다면 각각의 반복자와 인덱스 변수를 사용해 엄격하고 명시적으로 제어해야 한다.

## 아이템 59 라이브러리를 익히고 사용하라
표준 라이브러리를 사용했을 때 이점
1. 그 코드를 작성한 전문가의 지식과 여러분보다 앞서 사용한 다른 프로그래머들의 경험을 활용할 수 있다. 
2. 핵심적인 일과 크게 관련 없는 문제를 해결하느라 시간을 허비하지 않아도 된다.
3. 따로 노력하지 않아도 성능이 지속해서 개선된다.
4. 기능이 점점 많아 진다.
5. 여러분이 작성한 코드가 많은 사람에게 낯익은 코드가 된다는 것이다.

라이브러리가 너무 방대하여 모든 API 문서를 공부하기에는 벅차다 자바 프로그래머라면 적어도 `java.lang, java.util, java.io와 그 하위 패키지들에는 익숙해져야 한다. 또 컬렉션 프레임워크, 스트림 라이브러리 java.util.concurrent의 동시성 기능도 마찬가지다.`

## 아이템 60. 정확한 답이 필요하다면 float와 double은 피하라
float와 double 타입은 과학과 공학 계산용으로 설계되었다. 이진 부동소수점 연산에 쓰이며, 넓은 범위의 수를 빠르게 정밀한 근사치로 계산하도록 세심하게 설계되었다. 따라서 __정확한 계산이 필요할 때는 사용하면 안 된다.__ `금융 계산에는 BigDecimal, int or long을 사용해야 한다.`

BigDecimal의 단점으로 기본 타입보다 쓰기가 훨씬 불편하고, 훨씬 느리다. 

## 아이템 61. 박싱된 기본 타입보다는 기본 타입을 사용하라
자바의 기본타입 int, double, boolean 등에는 대응 하는 참조타입이 하나씩 있다. 이를 박싱된 기본타입 이라고 한다. Integer, Double, Boolean 등이다. 기본타입과 박싱된 기본타입의 주된 차이로는
1. 기본 타입은 값만 가지고 있으나 박싱된 기본 타입은 값에 더해 __식별성__ 이란 속성을 갖는다. 즉 값이 같아도 서로 다르다고 식별될 수 있다.
2. 기본 타입의 값은 언제나 유효하나 박싱된 기본 타입은 유효하지 않은 값, 즉 null을 가질 수 있다.
3. 기본 타입이 박싱된 기본 타입보다 시간과 메모리 사용면에서 더 효율적이다.

같은 객체를 비교하는 게 아니라면 박싱된 기본 타입에 == 연산자를 사용하면 오류가 일어난다. 또 거의 예외 없이 기본 타입과 박싱된 기본 타입을 혼용한 연산에서는 박싱된 기본 타입의 박싱이 자동으로 풀린다. 그리고 null 참조를 언박싱 하면 NullPointException이 발생한다.

그렇다면 박싱된 기본 타입은 언제 써야 하는가?
1. 컬렉션의 원소, 키, 값으로 쓰인다. (컬렉션은 기본 타입을 담을 수 없으므로)
2. 매개변수화 타입이나 매개변수화 메서드의 타입 매개변수로는 박싱된 기본 타입을 써야 한다.
3. 리플렉션을 통해 메서드를 호출할 때도 박싱된 기본 타입을 사용해야 한다.

## 아이템 62. 다른 타입이 적절하다면 문자열 사용을 피하라
문자열은 다른 값 타입을 대신하기에 적합하지 않다. 키보드로 입력 받을때 주로 문자열을 사용한다. 하지만 입력 받을 데이터가 진짜 문자열일 때만 그렇게 사용하는 것이 좋다. 수치형인 경우 int, float 등 적당한 수치 타입으로 변환하고, 예/아니오 질문에 대한 답이라면 적절한 열거 타입이나 boolean 타입으로 변환해야 한다.

문자열은 열거 타입을 대신하기에 좋지 않다. 또 문자열은 혼합 타입을 대신하기에 적합하지 않다.
```java
//혼합 타입 예
String compoundKey = className + "#" + i.next();
```
위 방식에는 단점이 많다. 각 요소를 개별로 접근하려면 문자열을 파싱해야 해서 느리고, 오류 가능성도 커진다. 적절한 equals, toString, compareTo 메서드를 제공할 수 없으며 String이 제공하는 기능에만 의존해야 한다. 그래서 차라리 전용 클래스를 새로 만드는 편이 낫다.

또 문자열은 권한을 표현하기에 적합하지 않다.

## 아이템 63. 문자열 연결은 느리니 주의하라
문자열 연결 연산자로 문자열 n개를 잇는 시간은 n²에 비례한다. 문자열은 불변이라서 두 문자열을 연결할 경우 양쪽의 내용을 모두 복사해야 하므로 성능 저하는 피할 수 없는 결과다. `성능을 포기하고 싶지 않다면 String 대신 StringBuilder를 사용하자`

## 아이템 64. 객체는 인터페이스를 사용해 참조하라
적합한 인터페이스만 있다면 매개변수뿐 아니라 반환값, 변수, 필드를 전부 인터페이스 타입으로 선언하라. `객체의 실제 클래스를 사용해야할 상황은 오직 생성자로 생성할 때`뿐이다. 인터페이스를 타입으로 사용하는 습관을 길러두면 프로그램이 훨씬 유연해질 것이다.

적합한 인터페이스가 없다면 당연히 클래스로 참조해야 한다.
1. 값 클래스 같은 경우 여러가지로 구현될 수 있다고 생각하고 설계되는 일은 거의 없다. 따라서 final인 경우가 많고 상응하는 인터페이스가 별로 존재하는 경우가 드물다.
2. 클래스 기반으로 작성된 프레임워크가 제공하는 객체들이 있다. 이런 경우라도 특정 구현 클래스보다는 기반 클래스를 사용해 참조하자
3. 인터페이스에는 없는 특별한 메서드를 제공하는 클래스들이 있다.

적합한 인터페이스가 없다면 클래스의 계층구조 중 필요한 기능을 만족하는 가장 덜 구체적인 클래스를 타입으로 사용하자

## 아이템 65. 리플렉션보다는 인터페이스를 사용하라
리플렉션 기능 `java.lang.reflect` 을 이용하면 프로그램에서 임의의 클래스에 접근할 수 있다. Class 객체가 주어지면 그 클래스의 생성자, 메서드, 필드에 해당하는 Constructor, Method, Field 인스턴스를 가져올 수 있고, 이 인스턴스들로는 그 클래스의 멤버 이름, 필드 타입, 메서드 시그니처 등을 가져올 수 있다.

[리플렉션을 이용했을 때 단점]
1. 컴파일 타입 검사가 주는 이점을 하나도 누릴 수 없다.
2. 리플렉션을 이용하면 코드가 지저분하고 장황해진다.
3. 성능이 떨어진다. - 리플렉션을 통한 메서드 호출은 일반 메서드 호출보다 훨씬 느리다.

리플렉션은 아주 제한된 형태로만 사용해야 그 단점을 피하고 이점만 취할 수 있다. 리플렉션은 인스턴스 생성에만 쓰고, 이렇게 만든 인스턴스는 인터페이스나 상위 클래스로 참조해 사용하자

```java
public static void main(String[] args) {
	Class<? extends Set<String>> cl = null;

	try {
		cl = (Class<? extends Set<String>>) Class.forName(args[0]);
	} catch(ClassNotFoundException e) {
		fatalError("클래스를 찾을 수 없습니다.");
	}

	Constructor<? extends Set<String>> cons = null;
	try {
		cons = cl.getDeclaredConstructor();
	} catch(NoSuchMethodException e) {
		fatalError("매개변수 없는 생성자를 찾을 수 없습니다.");
	}

	Set<String> s = null;
	try{
		s = cons.newInstance();
	}catch(IllegalAccessException e) {
		fatalError("생성자에 접근할 수 없습니다.");
	}catch(InstantiationException e) {
		fatalError("클래스를 인스턴스화할 수 없습니다.");
	}catch(InvocationTargetException e) {
		fatalError("생성자가 예외를 던졌습니다: " + e.getCause());
	}catch(ClassCastException e) {
		fatalError("Set을 구현하지 않은 클래스입니다.");
	}
}
```
위 예에서 리플렉션의 단점 두 가지를 보여준다.
1. 런타임에 총 여섯 가지나 되는 예외를 던질 수 있다.
2. 클래스 이름만으로 인스턴스를 생성해내기 위해 많은 코드를 작성했다.

리플렉션이 아니라면 생성자 호출 한 줄로 끝났을 일이다. 드물게 리플레션은 런타임에 존재하지 않을 수도 있는 다른 클래스 메서드, 필드와의 의존성을 관리할 때 적합하다.

## 아이템 66. 네이티브 메서드는 신중히 사용하라
자바 네이티브 인터페이스는 자바 프로그램이 네이티브 메서드를 호출하는 기술이다. (네이티브 메서드란 C, C++ 같은 네이티브 프로그래밍 언어로 작성한 메서드를 말함)

[네이티브 메서드의 주요 쓰임]
1. 레지스트리 같은 플랫폼 특화 기능을 사용한다.
2. 네이티브 코드로 작성된 기존 라이브러리를 사용한다.
3. 성능 개선을 목적으로 성능에 결정적인 영향을 주는 영역만 따로 네이티브 언어로 작성한다.

[네이티브 메서드의 주요 단점]
* 네이티브 언어가 안전하지 않으므로 네이티브 메서드를 사용하는 애플리케이션도 메모리 훼손 오류로부터 더 이상 안전하지 않다.
* 이식성이 낮다. 디버깅도 더 어렵다.
* 가비지 컬렉터가 네이티브 메모리는 자동 회수하지 못하고, 추적조차 할 수 없다.

## 아이템 67. 최적화는 신중히 하라
최적화는 좋은 결과보다는 해로운 결과로 이어지기 쉽다. 빠른 프로그램보다는 좋은 프로그램을 작성하자. 좋은 프로그램은 정보 은닉 원칙을 따르므로 개별 구성요소의 내부를 독립적으로 설계할 수 있다.

구현상의 문제는 나중에 최적화해 해결할 수 있지만 아키텍처의 결함이 성능을 제한하는 상황이라면 시스템 전체를 다시 작성하지 않고는 해결하기 불가능할 수 있다. 따라서 설계 단계에서 성능을 반드시 염두해 두어야 한다.

1. 성능을 제한하는 설계는 피하자
2. API를 설계할 때 성능에 주는 영향을 고려하자

## 아이템 68. 일반적으로 통용되는 명명 규칙을 따르라
패키지와 모듈 이름은 각 요소를 점으로 구분하여 계층적으로 짓는다. 요소들은 모두 소문자 알파벳 또는 숫자로 이뤄지고, 각 요소는 일반적으로 8자 이하의 짧은 단어로 한다.

클래스와 인터페이스의 이름은 하나 이상의 단어로 이뤄지며, 각 단어는 대문자로 시작한다. 메서드와 필드 이름은 첫 글자를 소문자로 쓴다는 점만 빼면 클래스와 명명 규칙이 같다. 상수 필드는 필드를 구성하는 단어 모두 대문자로 쓰며 단어 사이는 밑줄로 구분한다.

객체를 생성할 수 있는 클래스의 이름은 보통 단수 명사나 명사구를 사용한다. 객체를 생성할 수 없는 클래스의 이름은 보통 복수형 명사로 짓는다. 객체의 타입을 바꿔서 다른 타입의 또 다른 객체를 반환하는 인스턴스 메서드의 이름은 보통 toType 형태로 짓는다. 객체의 내용을 다른 뷰로 보여주는 메서드의 이름은 asType, 객체의 값을 기본 타입 값으로 반환하는 메서드의 이름은 보통 typeValue 형태로 짓는다.