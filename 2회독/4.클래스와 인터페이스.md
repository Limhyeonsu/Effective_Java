# 4. 클래스와 인터페이스
## 아이템 15. 클래스와 멤버의 접근 권한을 최소화하라
어설플게 설계된 컴포넌트와 잘 설계된 컴포넌트의 가장 큰 차이는 클래스 내부 데이터와 내부 구현 정보를 외부 컴포넌트로부터 얼마나 잘 숨겼느냐다.

[정보 은닉의 장점]
* 시스템 개발 속도를 높인다.
* 시스템 관리 비용을 낮춘다.
* 성능 최적화에 도움을 준다.
* 소프트웨어 재사용성을 높인다.
* 큰 시스템을 제작하는 난이도를 낮춰준다.

정보은닉을 위한 장치로 접근제한자를 사용한다. 기본 원칙은 `모든 클래스와 멤버의 접근성을 가능한 한 좁혀야 한다.` 즉 소프트웨어가 올바로 동작하는 한 항상 가장 낮은 접근 수준을 부여해야 한다는 뜻이다.
접근 수준을 public으로 선언하면 공개 API가 되고, package-private으로 선언하면 해당 패키지 안에서만 이용할 수 있다. 패키지 외부에서 사용할 이유가 없다면 package-private으로 선언하자

* private : 멤버를 선언한 톱레벨 클래스에서만 접근할 수 있다.
* package-private : 멤버가 소속된 같은 패키지 안의 모든 클래스에서 접근할 수 있다.
* protected: 멤버를 선언한 하위 클래스에서도 접근할 수 있다.
* public : 모든 곳에서 접근할 수 있다.

public 클래스의 protected 멤버는 공개 API이므로 영원히 지원돼야 한다. 또 내부의 동작방식을 API 문서에 적어 사용자에게 공개해야 할 수도 있다. 따라서 protected 멤버의 수는 적을수록 좋다.

멤버의 접근성을 좁히지 못하게 방해하는 제약이 있다. 상위 클래스의 메서드를 재정의할 때는 그 접근 수준을 상위 클래스에서보다 좁게 설정할 수 없다는 것이다.(리스코프 치환 원칙을 지키기 위해)

또 단지 코드를 테스트하려는 목적으로 클래스, 인터페이스, 멤버의 접근 범위를 넓히려 할 때가 있다. 이때 적당한 범위(package-private)로 넓히는 것은 괜찮지만 공개 API로 만들어서는 안 된다.

`public static final` 필드는 반드시 기본 타입 값이나 불변 객체를 참조해야 한다. 가변 객체를 참조한다면 final이 아닌 필드에 적용되는 모든 불이익이 그대로 적용된다. 따라서 클래스에서 public static final 배열 필드를 두거나
이 필드를 반환하는 접근자 메서드를 제공해서는 안 된다.

자바9에서는 모듈 시스템이라는 개념이 도입되면서 암묵적인 접근 수준이 추가되었다. 패키지가 클래스의 묶음이듯 모듈은 패키지들의 묶음이다. 모듈은 자신에 속하는 패키지 중에 공개할 것들을 선언한다.
protected, public 멤버라도 해당 패키지를 공개하지 않았다면 모듈 외부에서는 접근할 수 없다. 암묵적인 접근 수준은 숨겨진 패키지 안에 있는 public 크래스의 public 혹은 protected 멤버와 관련이 있다. 이들의 효과는 모듈 내부로 한정되어 있다.

## 아이템 16. public 클래스에서는 public 필드가 아닌 접근자 메서드를 사용하라
```java
class Point {
    public double x;
    public double y;
}
```
이런 클래스는 데이터 필드에 직접 접근할 수 있으니 캡슐화의 이점을 제공하지 못한다.
```java
class Point {
    private double x;
    private double y;
    
    public Point(double x, double y) {
        this.x = x;
        this.y = y;
    }
    
    public double getX() {return x;}
    public double getY() {return y;}
    
    public void setX(double x) { this.x = x;}
    public void setY(double y) { this.x = y;}
}
```
public 클래스에서는 위 처럼 패키지 밖에서 접근하려면 접근자를 제공하여 클래스 내부 표현 방식을 언제든 바꿀 수 있는 유연성을 얻을 수 있다.

`public 클래스는 절대 가변 필드를 직접 노출해서는 안 된다.`

## 아이템 17. 변경 가능성을 최소화하라
불변 클래스란 그 인스턴스의 내부 값을 수정할 수 없는 클래스다. 불변 클래스는 가변 클래스보다 설계하고 구현하고 사용하기 쉬우며, 오류가 생길 여지도 적고 훨씬 안전하다. 불변 클래스를 만들기 위해서는 다음의 규칙을 따르면 된다.
1. 객체의 상태를 변경하는 메서드를 제공하지 않는다.
2. 클래스를 확장할 수 없도록 한다. (상속을 막는 대표적인 방법은 클래스를 final로 선언하는 것이다.)
3. 모든 필드를 final로 선언한다.
4. 모든 필드를 private으로 선언한다.
5. 자신 외에는 내부의 가변 컴포넌트에 접근할 수 없도록 한다.

```java
public final class Complex {
    private final double re;
    private final double im;
    
    public Complex(double re, double im) {
        this.re = re;
        this.im = im;
    }
    
    public Complex plus(Complex c) {
        return new Complex(re+c.re, im+c.im);
    }
    
    public Complex minus(Complex c) {
        return new Complex(re - c.re, im - c.im);
    }
    
    //.....
}
```
위 예제에서는 메스드들이 인스턴스 자신은 수정하지 않고 새로운 Complex 인스턴스를 만들어 반환한다. 이처럼 피연산자에 함수를 적용해 그 결과를 반환하지만 피연산자 자체는 그대로인 프로그래밍 패턴을 __함수형 프로그래밍__ 이라 한다.
이렇게 함수형 프로그래밍을 사용하면 코드에서 불변이 되는 영역의 비율이 높아지는 장점을 누릴 수 있다. 

불변 객체는 생성된 시점의 상태를 파괴될 때까지 그래도 간직하므로 단순하다. 또 근본적으로 스레드 안전하여 따로 동기화할 필요 없다. 불변 객체에 대해서는 그 어떤 스레드도 다른 스레드에 영향을 줄 수 없으니 __불변 객체는 안심하고 공유할 수 있다.__

불변 객체를 자유롭게 공유할 수 있다는 점은 방어적 복사도 필요 없다는 결론으로 자연스럽게 이어진다. (아무리 복사해봐야 원본과 똑같으므로) 그래서 불변 클래스는 clone 메서드나 복사 생성자를 제공하지 않는 게 좋다.
또 불변 객체는 자유롭게 공유할 수 있음은 물론, 불변 객체끼리는 내부 데이터를 공유할 수 있다.

불변 객체는 그 자체로 실패 원자성을 제공한다. 상태가 절대 변하지 않으니 잠깐이라도 불일치 상태에 빠질 가능성이 없다. 불변 객체의 단점으로는 값이 다르다면 반드시 독립된 객체로 만들어야 한다는 것이다.

클래스가 불변임을 보장하려면 자신을 상속하지 못하게 해야한다고 했다. 가장 쉬운 방법은 final 클래스로 선언하는 것이지만 더 유연한 방법으로 모든 생성자를 private or package-private으로 만들고 public 정적 팩터리를 제공하는 방법이다.
```java
public class Complex {
    private final double re;
    private final double im;
    
    private Complex(double re, double im) {
        this.re = re;
        this.im = im;
    }
    public static Complex valueOf(double re, double im) {
        retuen new Complex(re, im);
    }
}
```

정리) getter가 있다고 해서 무조건 setter를 만들지는 말자 클래스는 꼭 필요한 경우가 아니면 불변이어야 한다. 그렇다 해도 모든 클래스를 불변으로 만들 수는 없다. 불변으로 만들 수 없는 클래스라도 변경할 수 있는 부분을 최소한으로 줄이자
그리고 꼭 변경해야 할 필드를 뺀 나머지는 모두 final로 선언하자 (다른 이유가 없다면 모든 필드는 __private final__ 이어야 한다.), 또 생성자와 정적 팩터리 외에는 그 어떤 초기화 메서드도 public으로 제공해서는 안 된다.

## 아이템 18. 상속보다는 컴포지션을 사용하라
상위 클래스와 하위 클래스를 모두 같은 프로그래머가 통제하는 패키지 안에서라면 상속도 안전하다. 하지만 일반적인 구체 클래스를 패키지 경계를 넘어 다른 패키지의 구체 클래스를 상속하는 일은 위험하다.

메서드 호출과 달리 상속은 캡슐화를 깨뜨린다. 상위 클래스가 어떻게 구현되었느냐에 따라 하위 클래스의 동작에 이상이 생길 수 있다. 여러 문제를 피해가는 묘안으로 `기존 클래스를 확장하는 대신 새로운 클래스를 만들고
private 필드로 기존 클래스의 인스턴스를 참조하게 하자. 기존 클래스가 새로운 클래스의 구성요소로 쓰인다는 뜻에서 이런 설계를 컴포지션 이라 한다.`

상속은 반드시 하위 클래스가 상위 클래스의 __진짜 하위 타입인 상황__ 에서만 쓰여야 한다. 

컴포지션 대신 상속을 사용하기로 결정했다면 마지막으로 확장하려는 클래스의 API에 아무런 결함이 없는가를 생각해야 한다. 컴포지션으로는 이런 결함을 숨기는 새로운 API를 설계할 수 있지만, 상속은 상위 클래스의 API를 그 결함까지도 그대로 승계한다.

## 아이템 19. 상속을 고려해 설계하고 문서화하라. 그러지 않았다면 상속을 금지하라
메서드를 재정의하면 어떤 일이 일어나는지를 정확히 정리하여 문서로 남겨야 한다. 즉 상속용 클래스는 재정의할 수 있는 메서드들을 내부적으로 어떻게 이용하는지 문서로 남겨야 한다.
호출되는 메서드가 재정의 가능 메서드(public, protected 메서드중 final이 아닌 모든 메서드) 라면 그 사실을 호출하는 메서드의 API 설명에 적시해야 한다. 어떤 순서로 호출하는지, 각각의 호출 결과가 이어지는 처리에 어떤 영향을 주는지도 담아야 한다.

또 효율적인 하위 클래스를 큰 어려움 없이 만들 수 있게 하려면 클래스의 내부 동작 과정 중간에 끼어들 수 있는 Hook을 잘 선별하여 protected 메서드 형태로 공개해야 할 수도 있다.
protected 메서드 하나하나가 내부 구현에 해당하므로 그 수는 가능한 한 적어야 한다. 

상속용 클래스를 시험하는 방법은 직접 하위 클래스를 만들어보는 것이 유일하다. 하위 클래스를 여러 개 만들 때까지 전혀 쓰이지 않는 protected 멤버는 사실 private이었어야 할 가능성이 크다.
__상속용으로 설계한 클래스는 배포 전에 반드시 하위 클래스를 만들어 검증해야 한다.__

상속용 클래스의 생성자는 직접적으로든 간접적으로든 재정의 가능 메서드를 호출해서는 안 된다. 상위 클래스의 생성자가 하위 클래스의 생성자보다 먼저 실행되므로 하위 클래스에서 재정의한 메서드가 하위 클래스의 생성자보다 먼저 호출된다.

상속용으로 설계하지 않은 클래스는 상속을 금지하자. 상속을 금지하는 방법으로는
1. 클래스를 final로 선언하는 방법
2. 모든 생성자를 private or package-private으로 선언하고 public 정적 팩터리를 만들어주는 방법