# 8. 메서드

## 아이템 49. 매개변수가 유효한지 검사하라
메서드와 생성자 대부분은 입력 매개변수의 값이 특정 조건을 만족하기를 바란다. 그런 제약은 반드시 문서화해야 하며 메서드 몸체가 시작되기 전에 검사해야 한다. 메서드 몸체가 실행되기 전에 매개 변수를 확인한다면 잘못된 값이 넘어왔을 때 즉각적이고 깔끔한 방식으로 예외를 던질 수 있다. public과 protected 메서드는 매개변수 값이 잘못됐을 때 던지는 예외를 문서화해야 한다. 

자바 7에 추가된 requireNonNull 메서드를 사용하면 null 검사를 수동으로 하지 않아도 된다.

```java
Object.requiredNonNull(straregy, "전략");
```

public이 아닌 메서드라면 메서드가 호출되는 상황을 통제할 수 있다. 오직 유효한 값이 메서드에 넘겨지리라는 것을 보증할 수 있다. 그때 assert 단언문을 사용해 매개변수의 유효성을 검사할 수 있다.

```java
private static void sort(long a[], int offset, int length) {
    assert a != null;
    assert offset >= 0 && offset <= a.length;
    assert length >= 0 && a.length - offset;
    ...
}
```
단언문들은 자신이 단언한 조건이 무조건 참이라고 선언한다. 일반적인 유효성 검사와 다르게 실패하면 AssertionError를 던지고, 런타임에 아무런 효과도, 아무런 성능 저하도 없다.

생성자 매개변수의 유효성 검사는 클래스 불변식을 어기는 객체가 만들어지지 않게 하는데 꼭 필요하다.

메서드는 최대한 범용적으로 설계해야 한다. 메서드가 건네 받은 값으로 무언가 제대로 된 일을 할 수 있다면 매개변수 제약은 적을수록 좋다.

## 아이템 50. 적시에 방어적 복사본을 만들라
자바는 안전한 언어다. 자바로 작성한 클래스는 불변식이 지켜진다. 그렇다 해도 다른 클래스로부터의 침범을 아무 노력없이 막을 수 있는 것은 아니다. 그러므로 `방어적으로 프로그래밍 해야 한다.` 외부 공격으로부터 인스턴스의 내부를 보호하려면 생성자에서 받은 가변 매개변수 각각을 방어적으로 복사해야 한다.

```java
//변경전
public final class Period {
    private final Date start;
    private final Date end;
    
    public Period(Date start, Date end) {
        if(start.compareTo(end>0)
            throw new IllegalArgumentException(this.start + "가 " + this.end + "보다 늦다.")
        this.start = start;
        this.end = end;
    }
    ....

//변경 후
public Period(Date start, Date end) {
    this.start = new Date(start.getTime()); //방어적 복사본 생성
    this.end = new Date(end.getTime());
    
    //복사된 값으로 유효성 검사
    if(this.start.compareTo(this.end) > 0)
        throw new IllegalArgumentException(this.start + "가 " + this.end + "보다 늦다."); 
}
```
멀티 쓰레드 환경이라면 원본 객체의 유효성을 검사한 후 복사본을 만드는 그 찰나의 취약한 순간에 다른 스레드가 원본 객체를 수정할 위험이 있기 때문에 방어적 복사를 통하여 이런 위험한 상황에서 해방될 수 있다. 또 방어적 복사에 Date의 clone을 사용하지 않는다. final이 아닌 Date에서 clone을 정의한 것이 아닐 수 있다. 즉 clone이 악의를 가진 하위 클래스의 인스턴스를 반환할 수도 있다. 따라서 `매개변수가 제 3자에 의해 확잘될 수 있는 타입이라면 방어적 복사본을 만들 때 clone을 사용해서는 안 된다.`

생성자와 달리 접근자 메서드는 방어적 복사에 clone을 사용해도 된다.

매개벼수를 방어적으로 복사하는 목적이 불변 객체를 만들기 위해서만은 아니다. 메서드든 생성자든 클라이언트가 제공한 객체의 참조를 내부의 자료구조에 보관해야 할 때면 항시 그 객체가 잠재적으로 변경될 수 있는지를 생각해야 한다.

## 아이템 51. 메서드 시그니처를 신중히 설계하라
1. 메서드 이름을 신중히 짓자 - 항상 표준 명명 규칙을 따라야 한다. 같은 패키지에 속한 다른 이름들과 일관되게 짓는 것이 최우선 목표다.
2. 편의 메서드를 너무 많이 만들지는 말자 - 모든 메서드는 각각 자신의 소임을 다해야 한다. 메서드가 너무 많으면 이를 구현하는 사람과 사용하는 사람 모두를 고통스럽게 한다.
3. 매개변수 목록은 짧게 유지하자 - 4개 이하가 좋다. 긴 매개변수 목록을 짧게 줄여주는 기술로 다음과 같이 있다.
   1. 여러 메서드로 쪼갠다.
   2. 매개변수 여러 개를 묶어주는 도우미 클래스를 만든다.
   3. 객체 생성에 사용한 빌더 패턴을 메서드 호출에 응용한다.
4. 매개변수의 타입으로는 클래스보다는 인터페이스가 낫다. 또 boolean 타입 보다는 원소 2개짜리 열거 타입이 낫다.