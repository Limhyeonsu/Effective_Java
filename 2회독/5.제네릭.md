# 5. 제네릭
제네릭은 자바 5부터 사용가능하다. 제네릭을 사용하면 컬렉션이 담을 수 있는 타입을 컴파일러에 알려주게 된다. 그래서 컴파일러는 알아서 형변환 코드를 추가할 수 있게 되고 더 안전하고 명확한 프로그램을 만들어준다.

## 아이템 26. 로 타입은 사용하지 말라
클래스와 인터페이스 선언에 타입 매개변수가 쓰이면, 이를 제네릭 클래스 또는 제네릭 인터페이스라 한다. 그리고 이를 통틀어 __제네릭 타입__ 이라 한다.
제네릭 타입을 하나 정의하면 그에 딸린 Raw Type도 함께 정의된다.  예) List<E>의 로타입은 List다.

`오류는 가능한 한 발생 즉시, 이상적으로는 컴파일할 때 발견하는 것이 좋다.`

```java
private final Collection stamps = ....;

private final Collection<Stamp> stamps = ....;
```
이렇게 타입을 지정해주면 컴파일러는 Stamp 인스턴스만 넣어야함을 인지하게 되어 타입의 안전성을 확보할 수 있다. 그러므로 타입 매개변수가 없는 제네릭 타입인 로 타입은 절대로 써서는 안 된다. 로 타입을 사용하면 제네릭이 안겨주는 안전성과 표현력을 모두 잃게 된다.

매개변수로 List를 받는 메서드에 List<String>을 넘길 수 있지만 List<Object>를 받는 메서드에는 넘길 수 없다. 이는 제네릭의 하위 타입 규칙 때문이다. 즉 List<String>은 로 타입인 List의 하위 타입이지만, List<Object>의 하위 타입은 아니다.

제네릭 타입을 쓰고 싶지만 실제 타입 매개변수가 무엇인지 신경 쓰고 싶지 않다면 물음표를 사용하자.(비한정 와일드 카드 타입) 예) Set<?>
그렇다면 비한정 와일드 카드 타입을 사용하는 것과 로 타입의 차이는 무엇일까? `와일드 카드 타입은 안전하고, 로 타입은 안전하지 않다.`

예외적인 상황으로 class 리터럴 타입에는 로 타입을 써야 한다. 예) List.class, String[].class

또 런타임에는 제네릭 타입 정보가 지워지므로 instanceof 연산자는 비한정적 와일드카드 타입 이외의 매개변수화 타입에는 적용할 수 없다.

## 아이템 27. 비검사 경고를 제거하라
제네릭을 사용하기 시작하면 수많은 컴파일러 경고를 보게 된다. 할 수 있는 한 모든 비검사 경고를 제거하자 모두 제거한다면 그 코드는 타입 안전성이 보장된다. @SuppressWarnings("unchecked") 애너테이션을 달아 경고를 숨기자
이 애터네이션은 가능한 한 좁은 범위에 적용하자 심각한 경고를 놓칠 수 있으므로 절대 클래스 전체에 적용해서는 안 된다. (주로 변수 선언, 짧은 메서드, 생성자 등에 사용)

## 아이템 28. 배열보다는 리스트를 사용하라
배열과 제네릭 타입에 중요한 차이로
1. 배열은 공변이다. sub가 super의 하위타입이라면 sub[]는 super[]의 하위타입이 된다. 반면 제네릭은 불공변 이다. List<Type1>, List<Type2>는 하위 타입도 상위 타입도 아니다.
2. 배열은 실체화 된다. 배열은 런타임에도 자신이 담기로 한 원소의 타입을 인지하고 확인한다. 제네릭은 타입 정보가 런타임에는 소거 된다.

```java
Object[] objArr = new Long[1];
objArr[0] = "타입이 달라 넣을 수 없다.";

List<Object> ol = new ArrayList<Long>();
od.add("타입이 달라 넣을 수 없다.");
```
위 예제에서 어느 쪽이든 Long 용 저장소에 String을 넣을 수 없다. 배열에서는 그 실수를 런타임에 알게 되지만 List를 사용하면 컴파일할 때 바로 알 수 있다. new List[] 식으로 작성하면 컴파일시 제네릭 배열 생성 오류를 일으킨다.

제네릭에서는 원소의 타입 정보가 소거되어 런타임에는 무슨 타입인지 알 수 없음을 기억하자.
