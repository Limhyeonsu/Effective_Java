# 11. 동시성

## 아이템 78. 공유 중인 가변 데이터는 동기화해 사용하라
synchronized 키워드는 해당 메서드나 블록을 한번에 한 스레드씩 수행하도록 보장한다. 동기화가 없으면 한 스레드가 만든 변화를 다른 스레드에서 확인하지 못할 수 있다. 동기화는 일관성이 깨진 상태를 볼 수 없게 하는 것은 물론 동기화된 메서드나 블록에 들어간 스레드가 같은 락의 보호하에 수행된 모은 이전 수정의 최종 결과를 보게 해준다.

자바에서는 스레드가 필드를 읽을 때 항상 수정이 완전히 반영된 값을 얻는다고 보장하지만 한 스레드가 저장한 값이 다른 스레드에게 보이는가는 보장하지 않는다. `동기화는 배타적 실행뿐 아니라 스레드 사이의 안정적인 통신에 꼭 필요하다.`

다른 스레드를 멈추는 올바른 방법으로 첫 번째 스레드는 자신의 boolean 필드를 폴링하면서 그 값이 true가 되면 멈춘다. 이 필드를 false로 초기화해놓고, 다른 스레드에서 이 스레드를 멈추고자 할 때 true로 변경한다. 

여러 스레드가 가변 데이터를 공유한다면 그 데이터를 읽고 쓰는 동작은 반드시 동기화해야 한다.

## 아이템 79. 과도한 동기화는 피하라
과도한 동기화는 성능을 떨어트리고 교착상태에 빠뜨리고 심지어 예측할 수 없는 동작을 낳기도 한다. `응답 불가와 안전 실패를 피하려면 동기화 메서드나 동기화 블록 안에서는 제어를 절대로 클라이언트에 양도하면 안 된다.` 동기화된 영역 안에서는 재정의할 수 있는 메서드는 호출하면 안 되며 클라이언트가 넘겨준 함수 객체를 호출해서도 안 된다.

동기화 영역 바깥에서 호출되는 외계인 메서드를 열린 호출이라 한다. 외계인 메서드는 얼마나 오래 실행될지 알 수 없는데 동기화 영역 안에서 호출된다면 그동안 다른 스레드는 보호된 자원을 사용하지 목하고 대기해야만 한다. 따라서 열린 호출은 실패 방지 효과 외에도 동시성 효율을 크게 개선해준다. __동기화 영역에서는 가능한 한 일을 적게 하게 하자__

가변 클래스를 작성하려면 1)동기화를 전혀 하지 말고, 그 클래스를 동시에 사용해야 하는 클래스가 외부에서 알아서 동기화하게 하자 2)동기화를 내부에서 수행해 스레드 안전한 클래스로 만들자

정리) 교착상태와 데이터 훼손을 피하려면 동기화 영역 안에서 외계인 메서드를 절대 호출하지 말자. 동기화 영역 안에서의 작업은 최소한으로 줄이고 가변 클래스를 설계할 때는 스스로 동기화해야 할지 고민하자