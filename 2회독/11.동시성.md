# 11. 동시성

## 아이템 78. 공유 중인 가변 데이터는 동기화해 사용하라
synchronized 키워드는 해당 메서드나 블록을 한번에 한 스레드씩 수행하도록 보장한다. 동기화가 없으면 한 스레드가 만든 변화를 다른 스레드에서 확인하지 못할 수 있다. 동기화는 일관성이 깨진 상태를 볼 수 없게 하는 것은 물론 동기화된 메서드나 블록에 들어간 스레드가 같은 락의 보호하에 수행된 모은 이전 수정의 최종 결과를 보게 해준다.

자바에서는 스레드가 필드를 읽을 때 항상 수정이 완전히 반영된 값을 얻는다고 보장하지만 한 스레드가 저장한 값이 다른 스레드에게 보이는가는 보장하지 않는다. `동기화는 배타적 실행뿐 아니라 스레드 사이의 안정적인 통신에 꼭 필요하다.`

다른 스레드를 멈추는 올바른 방법으로 첫 번째 스레드는 자신의 boolean 필드를 폴링하면서 그 값이 true가 되면 멈춘다. 이 필드를 false로 초기화해놓고, 다른 스레드에서 이 스레드를 멈추고자 할 때 true로 변경한다. 

여러 스레드가 가변 데이터를 공유한다면 그 데이터를 읽고 쓰는 동작은 반드시 동기화해야 한다.

## 아이템 79. 과도한 동기화는 피하라
과도한 동기화는 성능을 떨어트리고 교착상태에 빠뜨리고 심지어 예측할 수 없는 동작을 낳기도 한다. `응답 불가와 안전 실패를 피하려면 동기화 메서드나 동기화 블록 안에서는 제어를 절대로 클라이언트에 양도하면 안 된다.` 동기화된 영역 안에서는 재정의할 수 있는 메서드는 호출하면 안 되며 클라이언트가 넘겨준 함수 객체를 호출해서도 안 된다.

동기화 영역 바깥에서 호출되는 외계인 메서드를 열린 호출이라 한다. 외계인 메서드는 얼마나 오래 실행될지 알 수 없는데 동기화 영역 안에서 호출된다면 그동안 다른 스레드는 보호된 자원을 사용하지 목하고 대기해야만 한다. 따라서 열린 호출은 실패 방지 효과 외에도 동시성 효율을 크게 개선해준다. __동기화 영역에서는 가능한 한 일을 적게 하게 하자__

가변 클래스를 작성하려면 1)동기화를 전혀 하지 말고, 그 클래스를 동시에 사용해야 하는 클래스가 외부에서 알아서 동기화하게 하자 2)동기화를 내부에서 수행해 스레드 안전한 클래스로 만들자

정리) 교착상태와 데이터 훼손을 피하려면 동기화 영역 안에서 외계인 메서드를 절대 호출하지 말자. 동기화 영역 안에서의 작업은 최소한으로 줄이고 가변 클래스를 설계할 때는 스스로 동기화해야 할지 고민하자

## 아이템 80. 스레드보다는 실행자, 태스크, 스트림을 애용하라
java.util.concurrent 패키지가 등장하였다. 이 패키지는 실행자 프레임워크라고 하는 인터페이스 기반의 유연한 태스크 실행 기능을 담고 있다.

```java
//작업 큐 생성
ExecutorService exec = Executors.newSingleThreadExecutor();

//실행자에 실행할 태스크 넘기기
exec.execute(runnable);

//실행자 종료
exec.shutdown();
```

큐를 둘 이상의 스레드가 처리하게 하고 싶다면 간단히 다른 정적 팩터리를 이용하여 다른 종류의 실행자 서비스(스레드 풀)를 생성하면 된다. 평범하지 않은 실행자를 원한다면 ThreadPoolExecutor 클래스를 직접 사용해도 된다. 이 클래스로는 스레드 풀 동작을 결정하는 거의 모든 속성을 설정할 수 있다.

작은 프로그램이나 가벼운 서버라면 Executors.newCachedThreadPool이 일반적으로 좋은 선택이다. 하지만 무거운 프로덕션 서버에는 좋지 못하다.

무거운 프로덕션 서버에서는 스레드 개수를 고정한 Executors.newFixedThreadPool을 선택하거나 완전히 통제할 수 있는 ThreadPoolExecutor를 직접 사용하는 편이 좋다.

작업 큐를 손수 만드는 일은 삼가야 하고, 스레드를 직접 다루는 것도 일반적으로 삼가야 한다. 실행자 프레임워크에서는 작업 단위와 실행 매커니즘이 분리된다. 작업 단위를 나타내는 개념이 태스크다. 태스크는 Runnable, Callable이 있다. 태스크를 수행하는 일반적인 매커니즘이 실행자 서비스이고, 태스크 수행을 실행자 서비스에 맡기면 원하는 태스크 수행 정책을 선택할 수 있고, 언제든 변경할 수 있다. __핵심은 실행자 프레임워크가 작업 수행을 담당해준다는 것이다.__

자바 7이 되면서 실행자 프레임워크는 포크-조인 태스크를 지원하도록 확장되었다. ForkJoinTask의 인스턴스는 작은 하위 태스크로 나뉠 수 있고, Pool을 구성하는 스레드들이 이 태스크들을 처리하며, 일을 먼저 끝낸 스레드는 다른 스레드의 남은 태스크를 가져와 대신 처리할 수도 있다.

## 아이템 81. wait와 notify 보다는 동시성 유틸리티를 애용하라
java.util.concurrent의 고수준 유틸리티는 세 범주로 나눌 수 있다. 실행자 프레임워크, 동시성 컬렉션, 동기화 장치다. 동시성 컬렉션은 List, Queue, Map 같은 표준 컬렉션 인터페이스에 동시성을 가미해 구현한 고성능 컬렉션이다. 높은 동시성에 도달하기 위해 동기화를 각자의 내부에서 수행한다. 따라서 동시성 컬렉션에서 동시성을 무력화하는 건 불가능하며 외부에서 락을 추가로 사용하면 오히려 속도가 느려진다.

동시성 컬렉션에서 동시성을 무력화하지 못하므로 여러 메서드를 원자적으로 묶어 호출하는 일 역시 불가능하다. 그래서 여러 기본 동작을 하나의 원자적 동작으로 묶는 상태 의존적 수정 메서드들이 추가되었다.
예)Map의 putIfAbsent(key, value) 메서드는 주어진 키에 매핑된 값이 아직 없을 때만 새 값을 집어넣는다. 그리고 기존 값이 있었다면 그 값을 반환하고, 없었다면 null을 반환한다.

ConcurrentHashMap은 동시성이 뛰어나며 속도도 무척 빠르다. 이제 Collections.synchronizedMap보다는 ConcurrentHashMap을 사용하는 것이 훨씬 좋다. 동기화된 맵을 동시성 맵으로 교체하는 것만으로 동시성 애플리케이션의 성능은 극적으로 개선된다.

Queue를 확장한 BlockingQueue에 추가된 메서드 중 take는 큐의 첫 원소를 꺼낸다. 이때 만약 큐가 비었다면 새로운 원소가 추가될 때까지 기다린다. 이러한 특성 때문에 BlockingQueue는 작업 큐로 쓰기에 적합하다. 작업큐는 하나 이상의 생산자 스테드가 작업을 큐에 추가하고, 하나 이상의 소비자 스레드가 큐에 있는 작업을 꺼내 처리하는 형태다.

동기화 장치는 스레드가 다른 스레드를 기다릴 수 있게 하여 서로 작업을 조율할 수 있게 해준다. 자주 쓰이는 동기화 장치는 CountDownLatch와 Semaphore다.  그리고 가장 강력한 동기화 장치는 바로 Phaser이다.

CountDownLatch는 일회성 장벽으로 하나 이상의 스레드가 또 다른 하나 이상의 스레드 작업이 끝날 때까지 기다리게 한다.

**시간 간격을 잴 때는 System.currentTimeMillis가 아닌 System.nanoTime을 사용하자 이것이 더 정확하고 정밀하며 시스템의 실시간 시계의 시간 보정에 영향받지 않는다.

```java
//wait 메서드를 사용하는 표준 방식
synchronized(obj) {
	while(<조건이 충족되지 않았다>)
		obj.wait();

	... //조건이 충족됐을 때의 동작을 수행
}
```

wait 메서드를 사용할 때는 반드시 대기 반복문 관용구를 사용하자 반복문 밖에서는 절대로 호출하지 말자

정리) java.util.concurrent는 고수준 언어에 비유할 수 있다. 코드를 새로 작성한다면 wait와 notify를 쓸 이유가 거의 없다. 이들을 사용하는 레거시 코드를 유지보수해야 한다면 wait는 항상 표준 관용구에 따라 while 문 안에서 호출하자 그리고 일반적으로 notify 보다는 notifyAll을 사용해야 한다.

## 아이템 82. 스레드 안전성 수준을 문서화하라
API 문서에 synchronized 한정자가 보이는 메서드는 스레드 안전하다는 말이 있지만 자바독이 기본 옵션에서 생성한 API 문서에는 synchronized 한정자가 포함되지 않는다. 메서드 선언에 synchronized 한정자를 선언할지는 구현 이슈일 뿐 API에 속하지 않는다.

멀티스레드 환경에서도 API를 안전하게 사용하게 하려면 클래스가 지원하는 스레드 안전성 수준을 정확히 명시해야 한다.
* 불변(immutable) : 이 클래스의 인스턴스는 상수와 같아서 외부 동기화도 필요 없다. 대표적으로 String, Long, BigInteger가 있다.
* 무조건적 스레드 안전(unconditionally thread-safe) : 이 클래스의 인스턴스는 수정될 수 있으나 내부에서 충실히 동기화하여 별도의 외부 동기화 없이 동시에 사용해도 안전하다.
* 조건부 스레드 안전(conditionally thread-safe) : 무조건적 스레드 안전과 같으나 일부 메서드는 동시에 사용하려면 외부 동기화가 필요하다.
* 스레드 안전하지 않음(not thread-safe) : 이 클래스의 인스턴스는 수정될 수 있다. ArrayList, HashMap 같은 기본 컬렉션이 속한다.
* 스레드 절대적(thread-hostile) : 이 클래스는 모든 메서드 호출을 외부 동기화로 감싸더라도 멀티스레드 환경에서 안전하지 않다.

클래스의 스레드 안전성은 보통 클래스의 문서화 주석에 기재하지만 독특한 특성의 메서드라면 해당 메서드의 주석에 기재하도록 하자, 반환 타입만으로는 명확히 알 수 없는 정적 팩터리라면 자신이 반환하는 객체의 스레드 안전성을 반드시 문서화해야 한다.

클라이언트가 공개된 락을 오래 쥐고 놓지 않는 서비스 거부 공격을 수행할 수도 있다. 서비스 거부 공격(DOS)을 막으려면 synchronized 메서드 대신 비공개 락 객체를 사용해야 한다.
```java
//final로 선언함으로써 우연히라도 락 객체가 교체되는 일을 예방해준다. 락 필드는 항상 final로 선언하자
private final Object lock = new Object();

public void foo() {
	synchronized(lock);
	...
}
```
비공개 락 객체는 클래스 바깥에서 볼 수 없으니 클라이언트가 그 객체의 동기화에 관여할 수 없다. `비공개 락 객체 관용구는 무조건적 스레드 안전 클래스에서만 사용할 수 있다.`

## 아이템 83. 지연 초기화는 신중히 사용하라
지연 초기화는 필드의 초기화 시점을 그 값이 처음 필요할 때까지 늦추는 기법이다. 그래서 값이 전혀 쓰이지 않으면 초기화도 결코 일어나지 않는다. 지연 초기화는 주로 최적화 용도로 쓰이지만, 클래스와 인스턴스 초기화 때 발생하는 위험한 순환 문제를 해결하는 효과도 있다.

지연 초기화는 양날의 검이다. 클래스 또는 인스턴스 생성시 초기화 비용은 줄지만 대신 지연 초기화하는 필드에 접근하는 비용은 커진다. 그럼에도 지연 초기화가 필요할 때는 해당 클래스의 인스턴스 중 그 필드를 사용하는 인스턴스의 비율이 낮은 반면 그 필드를 초기화하는 비용이 크다면 지연 초기화가 제 역할을 해줄 것이다.

멀티스레드 환경에서는 지연 초기화를 하기가 까다롭다. 지연 초기화하는 필드를 둘 이상의 스레드가 공유한다면 어떤 형태로든 반드시 동기화해야 한다.

```java
private final FieldType feild = computeFieldValue();
```
```java
private FieldType field;

private synchronized FieldType getField() {
    if(field == null) field = computeFieldValue();
    return field;
}
```
위 두 관용구는 정적 필드에도 똑같이 적용된다. 성능 때문에 정적 필드를 지연 초기화해야 한다면 지연 초기화 홀더 클래스 관용구를 사용하자
```java
private static class FieldHolder {
    static final FieldType field = computeFieldValue();
}

//getField가 처음 호출되는 순간 FieldHolder.field가 처음 읽히면서 FieldHolder 클래스 초기화를 촉발한다.
private static FieldType getField() {return FieldHolder.field;}
```

성능 때문에 인스턴스 필드를 지연 초기화해야 한다면 이중검사 관용구를 사용하라. 필드의 값을 두 번 검사하는 방식으로 한 번은 동기화 없이 검사하고, 두 번째는 동기화하여 검사한다. 두 번째 검사에서도 필드가 초기화되지 않았을 때만 필드를 초기화 한다. 필드가 초기화된 후로는 동기화하지 않으므로 해당 필드는 반드시 volatile로 선언해야 한다.

## 아이템 84. 프로그램의 동작을 스레드 스케줄러에 기대지 말라
여러 스레드가 실행 중이면 운영체제의 스레드 스케줄러가 어떤 스레드를 얼마나 오래 실행할지 정한다. 구체적인 스케줄링 정책은 운영체제마다 다를 수 있다. 정확성이나 성능이 스레드 스케줄러에 따라 달라지는 프로그램이라면 ㄷ른 플랫폼에 이식하기 어렵다.

견고하고 빠릿하고 이식성 좋은 프로그램을 작성하는 가장 좋은 방법은 실행 가능한 스레드의 평균적인 수를 프로세서 수보다 지나치게 많아지지 않도록 하는 것이다. 실행 가능한 스레드 수를 적게 유지하는 기법은 각 스레드가 무언가 유용한 작업을 완료한 후에는 다음 일거리가 생길 때까지 대기하도록 하는 것이다. __스레드는 당장 처리해야 할 작업이 없다면 실행돼서는 안 된다.__ 

스레드는 절대 바쁜 대기 상태가 되면 안 된다. 공유 객체의 상태가 바뀔 때까지 쉬지 않고 검사해서는 안 된다는 뜻이다. 바쁜 대기는 스레드 스케줄러의 변덕에 취약할 뿐 아니라 프로세서에 큰 부담을 주어 다른 유용한 작업이 실행될 기회를 박탈한다. 

특정 스레드가 다른 스레드들과 비교해 CPU 시간을 충분히 얻지 못해서 간신히 돌아가는 프로그램을 보더라도 Thread.yield를 써서 문제를 고쳐보려는 유혹을 떨쳐내자. 어느정도 호전될 수는 있으나 이식성은 그렇지 않을 것이다. 