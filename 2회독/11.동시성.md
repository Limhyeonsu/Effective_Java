# 11. 동시성

## 아이템 78. 공유 중인 가변 데이터는 동기화해 사용하라
synchronized 키워드는 해당 메서드나 블록을 한번에 한 스레드씩 수행하도록 보장한다. 동기화가 없으면 한 스레드가 만든 변화를 다른 스레드에서 확인하지 못할 수 있다. 동기화는 일관성이 깨진 상태를 볼 수 없게 하는 것은 물론 동기화된 메서드나 블록에 들어간 스레드가 같은 락의 보호하에 수행된 모은 이전 수정의 최종 결과를 보게 해준다.

자바에서는 스레드가 필드를 읽을 때 항상 수정이 완전히 반영된 값을 얻는다고 보장하지만 한 스레드가 저장한 값이 다른 스레드에게 보이는가는 보장하지 않는다. `동기화는 배타적 실행뿐 아니라 스레드 사이의 안정적인 통신에 꼭 필요하다.`

다른 스레드를 멈추는 올바른 방법으로 첫 번째 스레드는 자신의 boolean 필드를 폴링하면서 그 값이 true가 되면 멈춘다. 이 필드를 false로 초기화해놓고, 다른 스레드에서 이 스레드를 멈추고자 할 때 true로 변경한다. 

여러 스레드가 가변 데이터를 공유한다면 그 데이터를 읽고 쓰는 동작은 반드시 동기화해야 한다.

## 아이템 79. 과도한 동기화는 피하라
과도한 동기화는 성능을 떨어트리고 교착상태에 빠뜨리고 심지어 예측할 수 없는 동작을 낳기도 한다. `응답 불가와 안전 실패를 피하려면 동기화 메서드나 동기화 블록 안에서는 제어를 절대로 클라이언트에 양도하면 안 된다.` 동기화된 영역 안에서는 재정의할 수 있는 메서드는 호출하면 안 되며 클라이언트가 넘겨준 함수 객체를 호출해서도 안 된다.

동기화 영역 바깥에서 호출되는 외계인 메서드를 열린 호출이라 한다. 외계인 메서드는 얼마나 오래 실행될지 알 수 없는데 동기화 영역 안에서 호출된다면 그동안 다른 스레드는 보호된 자원을 사용하지 목하고 대기해야만 한다. 따라서 열린 호출은 실패 방지 효과 외에도 동시성 효율을 크게 개선해준다. __동기화 영역에서는 가능한 한 일을 적게 하게 하자__

가변 클래스를 작성하려면 1)동기화를 전혀 하지 말고, 그 클래스를 동시에 사용해야 하는 클래스가 외부에서 알아서 동기화하게 하자 2)동기화를 내부에서 수행해 스레드 안전한 클래스로 만들자

정리) 교착상태와 데이터 훼손을 피하려면 동기화 영역 안에서 외계인 메서드를 절대 호출하지 말자. 동기화 영역 안에서의 작업은 최소한으로 줄이고 가변 클래스를 설계할 때는 스스로 동기화해야 할지 고민하자

## 아이템 80. 스레드보다는 실행자, 태스크, 스트림을 애용하라
java.util.concurrent 패키지가 등장하였다. 이 패키지는 실행자 프레임워크라고 하는 인터페이스 기반의 유연한 태스크 실행 기능을 담고 있다.

```java
//작업 큐 생성
ExecutorService exec = Executors.newSingleThreadExecutor();

//실행자에 실행할 태스크 넘기기
exec.execute(runnable);

//실행자 종료
exec.shutdown();
```

큐를 둘 이상의 스레드가 처리하게 하고 싶다면 간단히 다른 정적 팩터리를 이용하여 다른 종류의 실행자 서비스(스레드 풀)를 생성하면 된다. 평범하지 않은 실행자를 원한다면 ThreadPoolExecutor 클래스를 직접 사용해도 된다. 이 클래스로는 스레드 풀 동작을 결정하는 거의 모든 속성을 설정할 수 있다.

작은 프로그램이나 가벼운 서버라면 Executors.newCachedThreadPool이 일반적으로 좋은 선택이다. 하지만 무거운 프로덕션 서버에는 좋지 못하다.

무거운 프로덕션 서버에서는 스레드 개수를 고정한 Executors.newFixedThreadPool을 선택하거나 완전히 통제할 수 있는 ThreadPoolExecutor를 직접 사용하는 편이 좋다.

작업 큐를 손수 만드는 일은 삼가야 하고, 스레드를 직접 다루는 것도 일반적으로 삼가야 한다. 실행자 프레임워크에서는 작업 단위와 실행 매커니즘이 분리된다. 작업 단위를 나타내는 개념이 태스크다. 태스크는 Runnable, Callable이 있다. 태스크를 수행하는 일반적인 매커니즘이 실행자 서비스이고, 태스크 수행을 실행자 서비스에 맡기면 원하는 태스크 수행 정책을 선택할 수 있고, 언제든 변경할 수 있다. __핵심은 실행자 프레임워크가 작업 수행을 담당해준다는 것이다.__

자바 7이 되면서 실행자 프레임워크는 포크-조인 태스크를 지원하도록 확장되었다. ForkJoinTask의 인스턴스는 작은 하위 태스크로 나뉠 수 있고, Pool을 구성하는 스레드들이 이 태스크들을 처리하며, 일을 먼저 끝낸 스레드는 다른 스레드의 남은 태스크를 가져와 대신 처리할 수도 있다.

## 아이템 81. wait와 notify 보다는 동시성 유틸리티를 애용하라
java.util.concurrent의 고수준 유틸리티는 세 범주로 나눌 수 있다. 실행자 프레임워크, 동시성 컬렉션, 동기화 장치다. 동시성 컬렉션은 List, Queue, Map 같은 표준 컬렉션 인터페이스에 동시성을 가미해 구현한 고성능 컬렉션이다. 높은 동시성에 도달하기 위해 동기화를 각자의 내부에서 수행한다. 따라서 동시성 컬렉션에서 동시성을 무력화하는 건 불가능하며 외부에서 락을 추가로 사용하면 오히려 속도가 느려진다.

동시성 컬렉션에서 동시성을 무력화하지 못하므로 여러 메서드를 원자적으로 묶어 호출하는 일 역시 불가능하다. 그래서 여러 기본 동작을 하나의 원자적 동작으로 묶는 상태 의존적 수정 메서드들이 추가되었다.
예)Map의 putIfAbsent(key, value) 메서드는 주어진 키에 매핑된 값이 아직 없을 때만 새 값을 집어넣는다. 그리고 기존 값이 있었다면 그 값을 반환하고, 없었다면 null을 반환한다.

ConcurrentHashMap은 동시성이 뛰어나며 속도도 무척 빠르다. 이제 Collections.synchronizedMap보다는 ConcurrentHashMap을 사용하는 것이 훨씬 좋다. 동기화된 맵을 동시성 맵으로 교체하는 것만으로 동시성 애플리케이션의 성능은 극적으로 개선된다.

Queue를 확장한 BlockingQueue에 추가된 메서드 중 take는 큐의 첫 원소를 꺼낸다. 이때 만약 큐가 비었다면 새로운 원소가 추가될 때까지 기다린다. 이러한 특성 때문에 BlockingQueue는 작업 큐로 쓰기에 적합하다. 작업큐는 하나 이상의 생산자 스테드가 작업을 큐에 추가하고, 하나 이상의 소비자 스레드가 큐에 있는 작업을 꺼내 처리하는 형태다.

동기화 장치는 스레드가 다른 스레드를 기다릴 수 있게 하여 서로 작업을 조율할 수 있게 해준다. 자주 쓰이는 동기화 장치는 CountDownLatch와 Semaphore다.  그리고 가장 강력한 동기화 장치는 바로 Phaser이다.

CountDownLatch는 일회성 장벽으로 하나 이상의 스레드가 또 다른 하나 이상의 스레드 작업이 끝날 때까지 기다리게 한다.

**시간 간격을 잴 때는 System.currentTimeMillis가 아닌 System.nanoTime을 사용하자 이것이 더 정확하고 정밀하며 시스템의 실시간 시계의 시간 보정에 영향받지 않는다.

```java
//wait 메서드를 사용하는 표준 방식
synchronized(obj) {
	while(<조건이 충족되지 않았다>)
		obj.wait();

	... //조건이 충족됐을 때의 동작을 수행
}
```

wait 메서드를 사용할 때는 반드시 대기 반복문 관용구를 사용하자 반복문 밖에서는 절대로 호출하지 말자

정리) java.util.concurrent는 고수준 언어에 비유할 수 있다. 코드를 새로 작성한다면 wait와 notify를 쓸 이유가 거의 없다. 이들을 사용하는 레거시 코드를 유지보수해야 한다면 wait는 항상 표준 관용구에 따라 while 문 안에서 호출하자 그리고 일반적으로 notify 보다는 notifyAll을 사용해야 한다. 