# 동시성
## 1. 공유중인 가변 데이터는 동기화해 사용하라
synchronized 키워드는 해당 메서드나 블록을 한번에 한 스레드씩 수행하도록 보장한다. 

동기화의 기능 : 
1. 한 객체가 일관된 상태를 가지고 생성되고 이 객체에 접근하는 메서드는 그 객체에 락을 건다. 락을 건 메서드는 객체의 상태를 확인하고 필요하면 수정한다. 즉 객체를 하나의 일관된 상태에서 다른 일관된 상태로 변화시킨다.  동기화는 어떤 메서드도 이 객체의 상태가 일관되지 않은 순간을 볼 수 없게 한다. 
2. 동기화 없이는 한 스레드가 만든 변화를 다른 스레드에서 확인하지 못할 수 있다. 동기화된 메서드나 블록에 들어간 스레드가 같은 락의 보호하에 수행된 모든 이전 수정의 최종 결과를 보게 해준다.

    public class StopThread{
        private static boolean stopRequested;

        public static void main(Stringp[] args) throws InterruptedException {
            Thread backgroudThread = new Thread(() -> {
                int i = 0;
                while(!stopRequested)
                    i++;
            });
            backgroudThread.start();

            TimeUnit.SECONDS.sleep(1);
            stopRequseted = true;
        }
    }

위 예제는 stopRequested 를 true로 설정하면 반복문을 빠져나올 것 같지만 무한반복문에 빠진다. 동기화 하지 않으면 메인 스레드가 수정한 값을 백그라운드 스레드가 언제 보게 될지 알 수 없다.

    //최적화한 코드
        if(!stopRequested)
            while(true)
                i++;

    //동기화 사용 버전
    public class StopThread{
        private static boolean stopRequested;

        private static synchronized void requestStop() {       //쓰기 메서드
            stopRequested = true;
        }

        private static synchronized boolean stopRequested() {  //읽기 메서드
            return stopRequested;
        }



        public static void main(Stringp[] args) throws InterruptedException {
            Thread backgroudThread = new Thread(() -> {
                int i = 0;
                while(!stopRequested())
                    i++;
            });
            backgroudThread.start();

            TimeUnit.SECONDS.sleep(1);
            requestStop();
        }
    }

쓰기 메서드, 읽기 메서드 모두 동기화되지 않으면 동작을 보장하지 않는다. 또 예제에서 stopRequested 필드를 volatile으로 선언하면 동기화를 생략해도 된다. volatile 한정자는 항상 가장 최근에 기록된 값을 읽게 됨을 보장한다.

    public class StopThread{
        private static volatile boolean stopRequested;

        public static void main(Stringp[] args) throws InterruptedException {
            Thread backgroudThread = new Thread(() -> {
                int i = 0;
                while(!stopRequested)
                    i++;
            });
            backgroudThread.start();

            TimeUnit.SECONDS.sleep(1);
            stopRequseted = true;
        }
    }

    // volatile은 주의해서 사용해야한다.
    private static volatile int nextSerialNumber = 0;

    public static int generateSerialNumber() {
        return nextSerialNumber++;
    }

증감 연산자의 경우 필드에 두 번 접근하게 된다(1. 값을 읽는다. 2. 새로운 값을 저장한다.) 이때 두번째 스레드가 비집고 들어오게 되면 첫 번째 스레드와 동일한 값을 돌려받게 되는 오류를 발생시킬 수 있다.

이때 generateSerialNumber() 메서드에 synchronized 한정자를 붙이면 문제는 해결된다. 단 synchronized를 붙였다면 필드에서는 volatile를 제거해야한다.

java.util.concurrent.atomic 패키지의 AtomicLong은 락 없이도 안전한 프로그래밍을 지원하는 클래스들을 가지고 있다. volatile은 동기화의 두 효과중 통신쪽만 지원하지만 이 패키지는 원자성까지 지원한다.

    //java.util.concurrent.atomic 패키지를 이용한 락프리 동기화
    private static final AtomicLong nextSerialNum = new AtomicLong();

    public static long generateSerialNumber(){
        return nextSerialNum.generateSerialNumber();
    }

위 문제들을 해결할 수 있는 가장 좋은 방법은 가변 데이터는 공유하지 않는 것이다. 가변 데이터는 단일 스레드에서만 사용하자

## 2. 과도한 동기화는 피하라
과도한 동기화는 성능을 떨어뜨리고, 교착 상태에 빠뜨리고, 예측할 수 없는 동작을 낳기도 한다.

응답불가와 안전 실패를 피하려면 동기화 메서드나 동기화 블록 안에서는 제어를 절대로 클라이언트에 양도하면 안된다. 

    //동기화 블록안에서 외계인 메서드 호출
    private void notifyElementAdded(E element) {
        synchronized(observers) {
            for(SetObserver<E> observer : observers)
                observer.added(this, element);
        }
    }

외계인 메서드가 하는 일에 따라 동기화된 영역은 예외를 일으키거나, 교착 상태에 빠지거나, 데이터를 훼손할 수 있다.

자바 언어의 락은 재진입을 허용하므로 교착상태에 빠지지는 않는다. 재진입 가능한 락은 객체 지향 멀티스레드 프로그램을 쉽게 구현할 수 있도록 해주지만 응답불가(교착상태)가 될 상황을 안전 실패(데이터 훼손)로 변모시킬 수 있다. 대부분 이런 문제는 외계인 메서드 호출을 동기화 블록 바깥으로 옮기면 된다.

    private void notifyElementAdded(E element) {
        List<SetObserver<E>> snapshot = null;
        synchronized(observers) {
            snapshot = new ArrayList<>(observers);
        }
        for(SetObserver<E> observer : observers)
            observer.added(this, element);
    }

더 나은 방법으로 자바의 동시성 컬렉션 라이브러리의 CopyOnWriteArrayList가 있다. ArrayList를 구현한 클래스로 내부를 변경하는 작업은 항상 깨끗한 복사본을 만들어 수행하도록 구현했다. 수정할 일은 드물고 순회만 빈번히 일어나는 관찰자 리스트 용도로 최적이다.

    private final List<SetObserver<E>> observers = new CopyOnWriteArrayList<>();

    public void addObserver(SetObserver<E> observer) {
        observers.add(observer);
    }

    public boolean removeObserver(SetObserver<E> observer) {
        return observers.remove(observer);
    }

    private void notipyElementAdded(E element) {
        for(SetObserver<E> observer : observers)
            observer.added(this, element);
    }

동기화 영역 바깥에서 호출되는 외계인 메서드를 열린 호출이라 한다. 열린 호출은 실패방지 효과외에도 동시성 효율을 크게 개선해준다.

기본 규칙은 동기화 영역에서는 가능한 한 일을 적게 하는 것이다.

가변 클래스를 작성하려면 다음의 두가지중 하나를 선택하자
1) 동기화를 전혀 하지 않고, 그 클래스를 동시에 사용해야 하는 클래스가 외부에서 알아서 동기화하게 하자
2) 동기화를 내부에서 수행해 스레드 안전한 클래스로 만들자 (외부에서 전체 락을 거는 것보다 동시성을 월등히 개선할 수 있을때만 선택하자)

또 여러 스레드가 호출할 가능성이 있는 메서드가 정적 필드를 수정한다면 그 필드를 사용하기 전에 반드시 동기해야한다.

**동기화 영역 안에서의 작업은 최소한으로 줄이자!

## 3. 스레드보다는 실행자, 태스크, 스트림을 애용하라
java.util.concurrent 패키지는 실행자 프레임워크라고 하는 인터페이스 기반의 유연한 태스크 실행 기능을 담고 있다.

    //실행자에 실행할 태스크를 넘긴다.
    ExecutorService exec = Executors.newSingleThreadExecutor();
    exec.execute(runnable);

    //실행자 종료
    exec.shutdown();

[실행자 서비스의 기능]
1) get 메서드 : 특정 태스크가 완료되기를 기다린다.
2) 태스크 모음 중 아무거나 혹 모든 태스크가 완료되기를 기다린다.
3) awaitTermination 메서드 : 실행자 서비스가 종료하기를 기다린다.
4) ExecuteorCompletionService : 완료된 태스크들의 결과를 차례로 받는다.
5) ScheduledThreadPoolExecutor : 태스크를 특정 시간에 혹은 주기적으로 실행하게 한다.

큐를 둘 이상의 스레드가 처리하게 하고 싶다면 다른 정적 팩터리를 이용하여 다른 종류의 실행자 서비스를 생성하면 된다. 평범하지 않은 실행자를 원한다면 ThreadPoolExecutor 클래스(스레드 풀 동작을 결정하는 거의 모든 속성을 설정)를 직접 사용해도 된다. 

작은 프로그램이나 가벼운 서버라면 특별히 설정할 게 없는 Executors.newCachedThreadPool을 사용하면 좋다.

CachedThreadPool은 요청받은 태스크들이 큐에 쌓이지 않고 즉시 스레드에 위임돼 실행되어 무거운 프로덕션 서버에는 좋지 못하다. 무거운 프로덕션 서버에서는 스레드 개수를 고정한 Executors.newFixedThreadPool을 선택하거나 ThreadPoolExecuotor를 직접 사용하는 것이 좋다.

작업 큐를 손수 만드는 일은 삼가고 스레드를 직접 다루는 것도 일반적으로 삼가야한다.

태스크를 수행하는 일반적인 매커니즘이 바로 실행자 서비스다. 태스크 수행을 실행자 서비스에 맡기면 원하는 태스크 수행 정책을 선택할 수 있고, 생각이 바뀌면 언제든 변경할 수 있다.

자바7에서는 실행자 프레임워크로 '포크-조인 태스크'를 지원하도록 확장되었다. ForkJoinTask의 인스턴스는 작은 하위 태스크로 나뉠 수 있고, 이를 구성하는 스레드들이 태스크들을 처리한다. 모든 스레드가 바쁘게 움직여 CPU를 최대한 활용하면서 높은 처리량과 낮은 지연시간을 달성한다.