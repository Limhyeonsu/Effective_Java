# 동시성
## 1. 공유중인 가변 데이터는 동기화해 사용하라
synchronized 키워드는 해당 메서드나 블록을 한번에 한 스레드씩 수행하도록 보장한다. 

동기화의 기능 : 
1. 한 객체가 일관된 상태를 가지고 생성되고 이 객체에 접근하는 메서드는 그 객체에 락을 건다. 락을 건 메서드는 객체의 상태를 확인하고 필요하면 수정한다. 즉 객체를 하나의 일관된 상태에서 다른 일관된 상태로 변화시킨다.  동기화는 어떤 메서드도 이 객체의 상태가 일관되지 않은 순간을 볼 수 없게 한다. 
2. 동기화 없이는 한 스레드가 만든 변화를 다른 스레드에서 확인하지 못할 수 있다. 동기화된 메서드나 블록에 들어간 스레드가 같은 락의 보호하에 수행된 모든 이전 수정의 최종 결과를 보게 해준다.

    public class StopThread{
        private static boolean stopRequested;

        public static void main(Stringp[] args) throws InterruptedException {
            Thread backgroudThread = new Thread(() -> {
                int i = 0;
                while(!stopRequested)
                    i++;
            });
            backgroudThread.start();

            TimeUnit.SECONDS.sleep(1);
            stopRequseted = true;
        }
    }

위 예제는 stopRequested 를 true로 설정하면 반복문을 빠져나올 것 같지만 무한반복문에 빠진다. 동기화 하지 않으면 메인 스레드가 수정한 값을 백그라운드 스레드가 언제 보게 될지 알 수 없다.

    //최적화한 코드
        if(!stopRequested)
            while(true)
                i++;

    //동기화 사용 버전
    public class StopThread{
        private static boolean stopRequested;

        private static synchronized void requestStop() {       //쓰기 메서드
            stopRequested = true;
        }

        private static synchronized boolean stopRequested() {  //읽기 메서드
            return stopRequested;
        }



        public static void main(Stringp[] args) throws InterruptedException {
            Thread backgroudThread = new Thread(() -> {
                int i = 0;
                while(!stopRequested())
                    i++;
            });
            backgroudThread.start();

            TimeUnit.SECONDS.sleep(1);
            requestStop();
        }
    }

쓰기 메서드, 읽기 메서드 모두 동기화되지 않으면 동작을 보장하지 않는다. 또 예제에서 stopRequested 필드를 volatile으로 선언하면 동기화를 생략해도 된다. volatile 한정자는 항상 가장 최근에 기록된 값을 읽게 됨을 보장한다.

    public class StopThread{
        private static volatile boolean stopRequested;

        public static void main(Stringp[] args) throws InterruptedException {
            Thread backgroudThread = new Thread(() -> {
                int i = 0;
                while(!stopRequested)
                    i++;
            });
            backgroudThread.start();

            TimeUnit.SECONDS.sleep(1);
            stopRequseted = true;
        }
    }

    // volatile은 주의해서 사용해야한다.
    private static volatile int nextSerialNumber = 0;

    public static int generateSerialNumber() {
        return nextSerialNumber++;
    }

증감 연산자의 경우 필드에 두 번 접근하게 된다(1. 값을 읽는다. 2. 새로운 값을 저장한다.) 이때 두번째 스레드가 비집고 들어오게 되면 첫 번째 스레드와 동일한 값을 돌려받게 되는 오류를 발생시킬 수 있다.

이때 generateSerialNumber() 메서드에 synchronized 한정자를 붙이면 문제는 해결된다. 단 synchronized를 붙였다면 필드에서는 volatile를 제거해야한다.

java.util.concurrent.atomic 패키지의 AtomicLong은 락 없이도 안전한 프로그래밍을 지원하는 클래스들을 가지고 있다. volatile은 동기화의 두 효과중 통신쪽만 지원하지만 이 패키지는 원자성까지 지원한다.

    //java.util.concurrent.atomic 패키지를 이용한 락프리 동기화
    private static final AtomicLong nextSerialNum = new AtomicLong();

    public static long generateSerialNumber(){
        return nextSerialNum.generateSerialNumber();
    }

위 문제들을 해결할 수 있는 가장 좋은 방법은 가변 데이터는 공유하지 않는 것이다. 가변 데이터는 단일 스레드에서만 사용하자